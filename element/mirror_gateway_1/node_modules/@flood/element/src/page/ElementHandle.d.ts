import { ElementHandle as PElementHandle, ClickOptions, ScreenshotOptions } from 'puppeteer';
import { ElementHandle as IElementHandle, Locator } from './types';
import { EvaluateFn } from '../runtime/types';
/**
 * @internal
 */
interface ScreenshotSaver {
    saveScreenshot(fn: (path: string) => Promise<boolean>): void;
}
/**
 * ElementHandle represents a remote element in the DOM of the browser. It implements useful methods for querying and interacting with this DOM element.
 *
 * All methods on this class are asynchronous and must be used with `await` to wait for the result to fulfill from the browser.
 */
export declare class ElementHandle implements IElementHandle, Locator {
    /**
     * @internal
     */
    private screenshotSaver;
    /**
     * @internal
     */
    errorString: string;
    /**
     * @internal
     */
    element: PElementHandle;
    constructor(elt: PElementHandle);
    initErrorString(foundVia?: string): Promise<ElementHandle>;
    bindBrowser(sss: ScreenshotSaver): void;
    toErrorString(): string;
    find(context: never, node?: never): Promise<ElementHandle | null>;
    findMany(context: never, node?: never): Promise<ElementHandle[]>;
    readonly pageFuncArgs: PElementHandle[];
    readonly pageFunc: EvaluateFn;
    readonly pageFuncMany: EvaluateFn;
    /**
     * Sends a click event to the element attached to this handle. If the element is
     * currently outside the viewport it will first scroll to that element.
     */
    click(options?: ClickOptions): Promise<void>;
    /**
     * Sends a click event to the element attached to this handle. If the element is
     * currently outside the viewport it will first scroll to that element.
     */
    doubleClick(options?: ClickOptions): Promise<void>;
    /**
     * Schedules a command to clear the value of this element.
     * This command has no effect if the underlying DOM element is neither a text
     * INPUT, SELECT, or a TEXTAREA element.
     */
    clear(): Promise<void>;
    /**
     * Sends focus to this element so that it receives keyboard inputs.
     */
    focus(): Promise<void>;
    /**
     * Clears focus from this element so that it will no longer receive keyboard inputs.
     */
    blur(): Promise<void>;
    /**
     * Sends a series of key modifiers to the element.
     */
    sendKeys(...keys: string[]): Promise<void>;
    /**
     * Sends a series of key presses to the element to simulate a user typing on the keyboard. Use this to fill in input fields.
     */
    type(text: string): Promise<void>;
    /**
     * Takes a screenshot of this element and saves it to the results folder with a random name.
     */
    takeScreenshot(options?: ScreenshotOptions): Promise<void>;
    findElement(locator: string | Locator): Promise<IElementHandle | null>;
    /**
     * Locates all elements using the supplied <[Locator]>, returning an array of <[ElementHandle]>'s
     */
    findElements(locator: string | Locator): Promise<IElementHandle[]>;
    /**
     * Fetches the remote elements `tagName` property.
     */
    tagName(): Promise<string | null>;
    /**
     * Fetches the remote elements `id` attribute.
     */
    getId(): Promise<string | null>;
    /**
     * Fetches the value of an attribute on this element
     */
    getAttribute(key: string): Promise<string | null>;
    /**
     * getProperty
     */
    getProperty(key: string): Promise<string | null>;
    /**
     * If the remote element is selectable (such as an `<option>` or `input[type="checkbox"]`) this methos will indicate whether it is selected.
     */
    isSelected(): Promise<boolean>;
    /**
     * Checks whether the remote element is selectable. An element is selectable if it is an `<option>` or `input[type="checkbox"]` or radio button.
     */
    isSelectable(): Promise<boolean>;
    /**
     * Checks whether the remote element is displayed in the DOM and is visible to the user without being hidden by CSS or occluded by another element.
     */
    isDisplayed(): Promise<boolean>;
    /**
     * Checks whether the remote element is enabled. Typically this means it does not have a `disabled` property or attribute applied.
     */
    isEnabled(): Promise<boolean>;
    /**
     * Get the visible (i.e. not hidden by CSS) innerText of this element, including sub-elements, without any leading or trailing whitespace.
     *
     * @returns {Promise<string>}
     * @memberof ElementHandle
     */
    text(): Promise<string>;
    /**
     * Returns a promise that will be resolved with the element's size
     * as a {width:number, height:number} object
     */
    size(): Promise<{
        width: number;
        height: number;
    }>;
    /**
     * Returns a promise that will be resolved to the element's location
     * as a {x:number, y:number} object.
     */
    location(): Promise<{
        x: number;
        y: number;
    }>;
    private readonly elementClient;
    private readonly elementRemoteObject;
    dispose(): Promise<void>;
    highlight(): Promise<void>;
    clearHighlights(): Promise<void>;
}
export {};
