"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Condition_1 = require("../Condition");
const Browser_1 = require("../../runtime/Browser");
class FrameCondition extends Condition_1.Condition {
    constructor(desc, id) {
        super(desc);
        this.id = id;
    }
    toString() {
        return `frame [name='${this.id}']`;
    }
    // public async waitFor(frame: Frame, page: Page): Promise<Frame | Error> {
    // 	let { timeout } = this
    // 	console.log(page.target().type())
    // 	page.on('framenavigated', frame => {
    // 		console.log(`Frame: '${frame.name()}'`)
    // 	})
    // 	return frame.waitForFunction(
    // 		(id: string) => {
    // 			function getFrames(frame) {
    // 				const frames = []
    // 				Array.from(frame.frames).forEach(f => {
    // 					frames.push(f)
    // 					frames.push(...getFrames(f))
    // 				})
    // 				return frames
    // 			}
    // 			let frames = getFrames(window)
    // 			return frames.find(frame => frame.name === id || frame.id === id)
    // 			// if (typeof title === 'string') {
    // 			// 	if (title.startsWith('/') && title.endsWith('/')) {
    // 			// 		// RegExp
    // 			// 		let exp = new RegExp(title.slice(1, title.length - 1))
    // 			// 		return exp.test(document.title)
    // 			// 	} else if (partial) {
    // 			// 		return document.title.indexOf(title) > -1
    // 			// 	} else {
    // 			// 		return document.title.trim() === title.trim()
    // 			// 	}
    // 			// }
    // 		},
    // 		{ polling: 'raf', timeout },
    // 		this.id,
    // 	)
    // }
    async waitFor(frame, page) {
        let waiterPromise = new Promise(yeah => {
            const cleanup = () => {
                page.removeListener('framenavigated', handler);
            };
            const handler = (frame) => {
                // console.log(`Frame: '${frame.name()}'`)
                if (frame.name() === this.id) {
                    cleanup();
                    yeah(frame);
                }
            };
            page.addListener('framenavigated', handler);
            if (typeof this.id === 'string') {
                // Check all existing frames as well to ensure we don't race
                let frames = Browser_1.getFrames(page.frames());
                for (const frame of frames) {
                    handler(frame);
                }
            }
            else {
                throw new Error(`Calling ableToSwitchFrame() with anything other than frame name or ID as a string is not yet supported.`);
            }
        });
        return Promise.race([waiterPromise, this.createTimeoutPromise()]).then(result => {
            clearTimeout(this.maximumTimer);
            return result;
        });
    }
    createTimeoutPromise() {
        // if (!this.timeout) return new Promise(() => {})
        const errorMessage = `Frame Wait Timeout Exceeded: ${this.timeout}ms exceeded`;
        return new Promise(yeah => (this.maximumTimer = setTimeout(yeah, this.timeout))).then(() => new Error(errorMessage));
    }
}
exports.FrameCondition = FrameCondition;
