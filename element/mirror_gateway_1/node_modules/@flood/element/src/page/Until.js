"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const TitleCondition_1 = require("./conditions/TitleCondition");
const ElementVisibilityCondition_1 = require("./conditions/ElementVisibilityCondition");
const ElementStateCondition_1 = require("./conditions/ElementStateCondition");
const ElementSelectedCondition_1 = require("./conditions/ElementSelectedCondition");
const ElementTextCondition_1 = require("./conditions/ElementTextCondition");
const URLCondition_1 = require("./conditions/URLCondition");
const DialogCondition_1 = require("./conditions/DialogCondition");
const FrameCondition_1 = require("./conditions/FrameCondition");
/**
 * Until contains a wealth of useful <Condition>s.
 *
 * <[Condition]>s represent predicates used to wait for something to become true.
 *
 * These predicates include waiting for elements to become active, visible, invisible or disabled on the page.
 *
 * You typically use these to control the flow of you test.
 *
 */
class Until {
    /**
     * Creates a condition that will wait until the input driver is able to switch to the designated frame.
     *
     * The target frame may be specified as:
     * - string name of the frame to wait for matching the frame's `name` or `id` attribute.
     * - (Coming soon) numeric index into window.frames for the currently selected frame.
     * - (Coming soon) locator which may be used to first locate a FRAME or IFRAME on the current page before attempting to switch to it.
     *
     * Upon successful resolution of this condition, the driver will be left focused on the new frame.
     */
    static ableToSwitchToFrame(frame) {
        return new FrameCondition_1.FrameCondition('ableToSwitchToFrame', frame);
    }
    /**
     * Creates a condition that waits for an alert to be opened. Upon success,
     * the returned promise will be fulfilled with the handle for the opened alert.
     */
    static alertIsPresent() {
        return new DialogCondition_1.DialogCondition('alertIsPresent');
    }
    /**
     * Creates a condition that will wait for the given element to be disabled
     * @param selectorOrLocator A <[Locatable]> to use to find the element.
     */
    static elementIsDisabled(selectorOrLocator) {
        return new ElementStateCondition_1.ElementStateCondition('elementIsDisabled', selectorOrLocator, true);
    }
    /**
     * Creates a condition that will wait for the given element to be enabled
     * @param selectorOrLocator A <[Locatable]> to use to find the element.
     */
    static elementIsEnabled(selectorOrLocator) {
        return new ElementStateCondition_1.ElementStateCondition('elementIsEnabled', selectorOrLocator, false);
    }
    /**
     * Creates a condition that will wait for the given element to be deselected.
     * @param selectorOrLocator A <[Locatable]> to use to find the element.
     */
    static elementIsSelected(selectorOrLocator) {
        return new ElementSelectedCondition_1.ElementSelectedCondition('elementIsSelected', selectorOrLocator, true);
    }
    /**
     * Creates a condition that will wait for the given element to be in the DOM, yet not visible to the user
     * @param selectorOrLocator A <[Locatable]> to use to find the element.
     */
    static elementIsNotSelected(selectorOrLocator) {
        return new ElementSelectedCondition_1.ElementSelectedCondition('elementIsNotSelected', selectorOrLocator, false);
    }
    /**
     * Creates a condition that will wait for the given element to be selected.
     *
     * Example:
     * ```typescript
     * step("Step 1", async browser => {
     *   await browser.wait(Until.elementIsVisible(By.partialLinkText("Start")))
     * })
     * ```
     *
     * @param selectorOrLocator A <[Locatable]> to use to find the element.
     */
    static elementIsVisible(selectorOrLocator) {
        return new ElementVisibilityCondition_1.ElementVisibilityCondition('elementIsVisible', selectorOrLocator, true, false);
    }
    /**
     * Creates a condition that will wait for the given element to become visible.
     *
     * Example:
     * ```typescript
     * step("Step 1", async browser => {
     * 	 await browser.click(By.css('.hide-panel'))
     *   await browser.wait(Until.elementIsNotVisible(By.id("btn")))
     * })
     * ```
     *
     * @param selectorOrLocator A <[Locatable]> to use to find the element.
     */
    static elementIsNotVisible(selectorOrLocator) {
        return new ElementVisibilityCondition_1.ElementVisibilityCondition('elementIsNotVisible', selectorOrLocator, false, true);
    }
    /**
     * Creates a condition which will wait until the element is located on the page.
     */
    static elementLocated(selectorOrLocator) {
        return new ElementVisibilityCondition_1.ElementLocatedCondition('elementLocated', selectorOrLocator, true);
    }
    /**
     * Creates a condition which will wait until the element's text exactly matches the target text, excluding leading and trailing whitespace.
     */
    static elementTextIs(selectorOrLocator, text) {
        return new ElementTextCondition_1.ElementTextCondition('elementTextIs', selectorOrLocator, text, false);
    }
    /**
     * Creates a condition which will wait until the element's text content contains the target text.
     */
    static elementTextContains(selectorOrLocator, text) {
        return new ElementTextCondition_1.ElementTextCondition('elementTextContains', selectorOrLocator, text, true);
    }
    /**
     * Creates a condition which will wait until the element's text matches the target Regular Expression.
     */
    static elementTextMatches(selectorOrLocator, regex) {
        return new ElementTextCondition_1.ElementTextCondition('elementTextMatches', selectorOrLocator, regex.toString());
    }
    /**
     * Creates a condition that will wait until at least the desired number of elements are found.
     */
    static elementsLocated(selectorOrLocator, desiredCount = 1) {
        return new ElementVisibilityCondition_1.ElementsLocatedCondition('elementsLocated', selectorOrLocator, desiredCount);
    }
    /**
     * Creates a condition that will wait for the given element to become stale.
     * An element is considered stale once it is removed from the DOM, or a new page has loaded.
     */
    // static stalenessOf(selectorOrLocator: NullableLocatable): Condition {
    // 	return
    // }
    /**
     * Creates a condition which waits until the page title contains the expected text.
     */
    static titleContains(title) {
        return new TitleCondition_1.TitleCondition('titleContains', title, true);
    }
    /**
     * Creates a condition which waits until the page title exactly matches the expected text.
     */
    static titleIs(title) {
        return new TitleCondition_1.TitleCondition('titleIs', title, false);
    }
    /**
     * Creates a condition which waits until the page title matches the title `RegExp`.
     */
    static titleMatches(title) {
        return new TitleCondition_1.TitleCondition('titleMatches', `${title}`, false);
    }
    /**
     * Creates a condition which waits until the page URL contains the expected path.
     */
    static urlContains(url) {
        return new URLCondition_1.URLCondition('urlContains', url, true);
    }
    /**
     * Creates a condition which waits until the page URL exactly matches the expected URL.
     */
    static urlIs(url) {
        return new URLCondition_1.URLCondition('urlIs', url, false);
    }
    /**
     * Creates a condition which waits until the page URL matches the supplied `RegExp`.
     */
    static urlMatches(url) {
        return new URLCondition_1.URLCondition('urlMatches', url.toString(), true);
    }
}
exports.Until = Until;
