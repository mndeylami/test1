"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ElementHandle_1 = require("./ElementHandle");
class NotImplementedError extends Error {
    constructor(message = 'Method not implemented in DSL') {
        super(message);
        this.message = message;
    }
}
exports.NotImplementedError = NotImplementedError;
function serializeArgument(arg) {
    if (Object.is(arg, undefined))
        return 'undefined';
    // if (typeof arg === 'function') return evaluationString(arg)
    return JSON.stringify(arg);
}
function evaluationString(fun, ...args) {
    return `(${fun})(${args.map(serializeArgument).join(',')})`;
}
class BaseLocator {
    constructor(errorString) {
        this.errorString = errorString;
    }
    toErrorString() {
        return this.errorString;
    }
    async find(context, node) {
        let handle = await context.evaluateHandle(this.pageFunc, ...this.pageFuncArgs, node);
        const element = handle.asElement();
        if (element)
            return new ElementHandle_1.ElementHandle(element).initErrorString(this.toErrorString());
        return null;
    }
    async findMany(context, node) {
        const arrayHandle = await context.evaluateHandle(this.pageFuncMany, ...this.pageFuncArgs, node);
        const properties = await arrayHandle.getProperties();
        await arrayHandle.dispose();
        const thisErrorString = this.toErrorString();
        const elements = [];
        for (const property of properties.values()) {
            const elementHandle = property.asElement();
            if (elementHandle)
                elements.push(new ElementHandle_1.ElementHandle(elementHandle).initErrorString(thisErrorString));
        }
        return Promise.all(elements);
    }
    async wait(frame, waitFunc, waitFuncArgs, options = {}) {
        const timeout = options.timeout || 3000;
        const waitForVisible = !!options.visible;
        const waitForHidden = !!options.hidden;
        const polling = waitForVisible || waitForHidden ? 'raf' : 'mutation';
        let tmpArgs = waitFuncArgs.map((_, index) => `arg${index}`);
        let fn = `
let element = ${evaluationString(this.pageFunc, ...this.pageFuncArgs)}
let predicate = ${waitFunc}
return predicate(${['element', ...tmpArgs].join(', ')})`;
        try {
            await frame.waitForFunction(new Function(...tmpArgs, fn), { polling, timeout }, ...waitFuncArgs);
        }
        catch (err) {
            console.error(err);
            return false;
        }
        return true;
    }
}
exports.BaseLocator = BaseLocator;
