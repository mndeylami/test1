"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Settings_1 = require("../runtime/Settings");
const recast = require("recast");
const prettier = require("prettier");
const Browser_1 = require("../runtime/Browser");
const debugFactory = require("debug");
const debug = debugFactory('element:page:condition');
/**
 * A Condition represents a predicate which can be used to wait for an <[ElementHandle]>. They are generally created by using <[Until]>'s helper methods.
 * @docOpaque
 */
class Condition {
    constructor(desc = '*BASE CONDITION') {
        this.desc = desc;
        this.hasWaitFor = true;
        this.settings = Settings_1.DEFAULT_SETTINGS;
    }
    async waitForEvent(page) {
        return;
    }
    get timeout() {
        return this.settings.waitTimeout * 1e3;
    }
}
exports.Condition = Condition;
class LocatorCondition extends Condition {
    constructor(desc = '*BASE CONDITION', locator, pageFunc, ...pageFuncArgs) {
        super(desc);
        this.desc = desc;
        this.pageFunc = pageFunc;
        this.locator = this.locatableToLocator(locator);
        this.pageFuncArgs = pageFuncArgs;
    }
    /**
     * @internal
     */
    locatableToLocator(el) {
        const e = new Error();
        Error.captureStackTrace(e);
        debug('e', e.stack);
        try {
            return Browser_1.locatableToLocator(el, `${this.desc}(locatable)`);
        }
        catch (e) {
            // TODO
            throw new Error(`condition '${this.desc}' unable to use locator: ${e}`);
        }
    }
}
exports.LocatorCondition = LocatorCondition;
class ElementCondition extends LocatorCondition {
    constructor(desc = '*BASE ELEMENT CONDITION', locator) {
        super(desc, locator, null);
    }
    get locatorPageFunc() {
        return this.locator.pageFunc;
    }
    async waitFor(frame, page) {
        const argSeparator = '-SEP-';
        let options = { polling: 'raf', timeout: this.timeout };
        let locatorFunc = this.locatorPageFunc;
        let conditionFunc = this.pageFunc;
        let fn = function predicate(...args) {
            const argSeparator = '-SEP-';
            let args1 = [];
            let args2 = [];
            let foundSep = false;
            for (const a of args) {
                if (!foundSep) {
                    if (a === argSeparator) {
                        foundSep = true;
                    }
                    else {
                        args1.push(a);
                    }
                }
                else {
                    args2.push(a);
                }
            }
            let locatorFunc = function () {
                return null;
            };
            let node = locatorFunc(...args1);
            if (node === null)
                return false;
            let conditionFunc = function (node, ...args2) {
                return false;
            };
            return conditionFunc(node, ...args2);
        };
        let fnAST = recast.parse(fn.toString());
        let locatorFuncAST = recast.parse(locatorFunc.toString()).program.body[0];
        if (!conditionFunc)
            throw new Error(`Condition.pageFunc is not defined`);
        let conditionFuncAST = recast.parse(conditionFunc.toString()).program.body[0];
        recast.visit(fnAST, {
            visitVariableDeclaration(path) {
                if (path.node.declarations[0].id.name === 'locatorFunc') {
                    path
                        .get('declarations', 0)
                        .get('init')
                        .replace(locatorFuncAST);
                }
                else if (path.node.declarations[0].id.name === 'conditionFunc') {
                    path
                        .get('declarations', 0)
                        .get('init')
                        .replace(conditionFuncAST);
                }
                this.traverse(path);
            },
        });
        let code = prettier.format(recast.print(fnAST).code, { parser: 'babylon' });
        debug('waitFor code', code);
        let args = Array.prototype.concat(this.locator.pageFuncArgs, argSeparator, this.pageFuncArgs);
        debug('waitFor args', args);
        code = `(${code})(...args)`;
        await frame.waitForFunction(code, options, ...args);
        return true;
    }
}
exports.ElementCondition = ElementCondition;
