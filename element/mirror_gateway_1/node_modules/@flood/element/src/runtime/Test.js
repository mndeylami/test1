"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// import NetworkRecorder from '../network/Recorder'
// import Observer from './Observer'
const Browser_1 = require("./Browser");
const Null_1 = require("./../reporter/Null");
const ObjectTrace_1 = require("../utils/ObjectTrace");
const Observer_1 = require("./test-observers/Observer");
const Lifecycle_1 = require("./test-observers/Lifecycle");
const Errors_1 = require("./test-observers/Errors");
const Inner_1 = require("./test-observers/Inner");
const StructuredError_1 = require("../utils/StructuredError");
const CancellationToken_1 = require("../utils/CancellationToken");
const Settings_1 = require("./Settings");
// import { ScreenshotOptions } from 'puppeteer'
// import { readdirSync } from 'fs'
const debugFactory = require("debug");
const debug = debugFactory('element:runtime:test');
class Test {
    constructor(client, script, reporter = new Null_1.NullReporter(), settingsOverride, testObserverFactory = x => x) {
        this.client = client;
        this.script = script;
        this.reporter = reporter;
        this.testObserverFactory = testObserverFactory;
        // public networkRecorder: NetworkRecorder
        // public observer: Observer
        this.testCancel = async () => { };
        this.iteration = 0;
        this.script = script;
        try {
            let { settings, steps } = script;
            this.settings = settings;
            this.steps = steps;
            // Adds output for console in script
            script.bindTest(this);
        }
        catch (err) {
            // XXX parsing errors. Lift to StructuredError?
            throw this.script.maybeLiftError(err);
        }
        Object.assign(this.settings, settingsOverride);
    }
    get skipping() {
        return this.failed;
    }
    async cancel() {
        this.failed = true;
        await this.testCancel();
    }
    async beforeRun() {
        debug('beforeRun()');
        await this.script.beforeTestRun();
    }
    /**
     * Runs the group of steps
     * @return {Promise<void|Error>}
     */
    async run(iteration) {
        await this.runWithCancellation(iteration || 0, new CancellationToken_1.CancellationToken());
    }
    async runWithCancellation(iteration, cancelToken) {
        console.assert(this.client, `client is not configured in Test`);
        const testObserver = new Errors_1.default(new Lifecycle_1.default(this.testObserverFactory(new Inner_1.default(new Observer_1.NullTestObserver()))));
        await (await this.client).reopenPage();
        this.testCancel = async () => {
            await testObserver.after(this);
        };
        this.failed = false;
        this.runningBrowser = null;
        // await this.observer.attachToNetworkRecorder()
        debug('run() start');
        const { testData } = this.script;
        try {
            const browser = new Browser_1.Browser(this.script.runEnv.workRoot, this.client, this.settings, this.willRunCommand.bind(this, testObserver), this.didRunCommand.bind(this, testObserver));
            this.runningBrowser = browser;
            if (this.settings.clearCache)
                await browser.clearBrowserCache();
            if (this.settings.clearCookies)
                await browser.clearBrowserCookies();
            if (this.settings.device)
                await browser.emulateDevice(this.settings.device);
            if (this.settings.userAgent)
                await browser.setUserAgent(this.settings.userAgent);
            if (this.settings.disableCache)
                await browser.setCacheDisabled(true);
            debug('running this.before(browser)');
            await testObserver.before(this);
            debug('Feeding data');
            let testDataRecord = testData.feed();
            if (testDataRecord === null) {
                throw new Error('Test data exhausted, consider making it circular?');
            }
            else {
                debug(JSON.stringify(testDataRecord));
            }
            debug('running steps');
            for (let step of this.steps) {
                browser.customContext = step;
                await Promise.race([
                    this.runStep(testObserver, browser, step, testDataRecord),
                    cancelToken.promise,
                ]);
                if (cancelToken.isCancellationRequested)
                    return;
                if (this.failed) {
                    console.log('failed, bailing out of steps');
                    break;
                }
            }
        }
        catch (err) {
            console.log('error -> failed');
            this.failed = true;
            throw err;
        }
        // TODO report skipped steps
        await testObserver.after(this);
    }
    get currentURL() {
        if (this.runningBrowser == null) {
            return '';
        }
        else {
            return this.runningBrowser.url;
        }
    }
    async runStep(testObserver, browser, step, testDataRecord) {
        let error = null;
        await testObserver.beforeStep(this, step);
        try {
            debug(`Run step: ${step.name}`); // ${step.fn.toString()}`)
            browser.settings = Object.assign({}, this.settings, step.stepOptions);
            await step.fn.call(null, browser, testDataRecord);
        }
        catch (err) {
            error = err;
        }
        if (error !== null) {
            debug('step error');
            console.log('step error -> failed');
            this.failed = true;
            await testObserver.onStepError(this, step, this.liftToStructuredError(error));
        }
        else {
            await testObserver.onStepPassed(this, step);
        }
        await testObserver.afterStep(this, step);
        if (error === null) {
            await this.doStepDelay();
        }
        // await this.syncNetworkRecorder()
        // this.networkRecorder.reset()
        debug('step done');
    }
    liftToStructuredError(error) {
        if (error.name.startsWith('AssertionError')) {
            return new StructuredError_1.StructuredError(error.message, { _kind: 'assertion' }, error).copyStackFromOriginalError();
        }
        else if (error._structured === 'yes') {
            return error;
        }
        else {
            // catchall - this should trigger a documentation request further up the chain
            return StructuredError_1.StructuredError.wrapBareError(error, { _kind: 'empty' }, 'test');
        }
    }
    /*
    private async didRunStep(name: string, screenshots: string[]): Promise<void> {
        if (this.skipped.length > 0) {
            debug('didRunStep - skipped', name)
            try {
                // Process skip callbacks
                for (const name of this.skipped) {
                    await this.didSkip(name)
                }
                this.skipped = []
            } catch (err) {
                console.error(`Error in skip callbacks`, err)
            }
        } else if (this.hasErrors) {
            debug('didRunStep - errors', name)
            this.skipAll = true
            try {
                // Process error callbacks
                for (const err of this.errors) {
                    await this.didError(err, name)
                }

                this.errors = []
            } catch (err) {
                console.error(`Error in error callbacks`, err)
            }
        } else {
            debug('didRunStep - succeeded', name)
            try {
                await this.didSucceed(name)
            } catch (err) {
                console.error(`Error in stepDidSucceed:`, err)
            }
        }
        return runCallback.apply(this, [CallbackQueue.AfterStep, name, screenshots])
    }
 */
    get stepNames() {
        return this.steps.map(s => s.name);
    }
    async doStepDelay() {
        if (this.skipping || this.settings.stepDelay <= 0) {
            return;
        }
        await new Promise(resolve => {
            if (!this.settings.stepDelay) {
                resolve();
                return;
            }
            setTimeout(resolve, this.settings.stepDelay * 1e3 || Settings_1.DEFAULT_STEP_WAIT_SECONDS * 1e3);
        });
    }
    async willRunCommand(testObserver, browser, command) {
        const step = browser.customContext;
        await testObserver.beforeStepAction(this, step, command);
        debug(`Before action: '${command}()' waiting on actionDelay: ${this.settings.actionDelay}`);
    }
    async didRunCommand(testObserver, browser, command) {
        await testObserver.afterStepAction(this, browser.customContext, command);
    }
    async takeScreenshot(options) {
        if (this.runningBrowser === null) {
            return [];
        }
        await this.runningBrowser.takeScreenshot(options);
    }
    async fetchScreenshots() {
        if (this.runningBrowser === null) {
            return [];
        }
        return this.runningBrowser.fetchScreenshots();
    }
    // private get numberOfBrowsers() {
    // try {
    // let lockFiles = readdirSync('/test/lock')
    // return lockFiles.length
    // } catch (err) {
    // return 1
    // }
    // }
    newTrace(step) {
        return new ObjectTrace_1.ObjectTrace(this.script.runEnv.workRoot, step.name);
    }
}
exports.default = Test;
