"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vm2_1 = require("vm2");
const Faker = require("faker");
const nodeAssert = require("assert");
const fs = require("fs");
const util_1 = require("util");
const exists = util_1.promisify(fs.exists);
const Step_1 = require("./Step");
const TestScript_1 = require("../TestScript");
const Settings_1 = require("./Settings");
const Expect_1 = require("../utils/Expect");
const Until_1 = require("../page/Until");
const By_1 = require("../page/By");
const Enums_1 = require("../page/Enums");
const TestDataLoaders_1 = require("../test-data/TestDataLoaders");
const debugFactory = require("debug");
const debug = debugFactory('element:runtime:eval-script');
// TODO work out the right type for floodElementActual
function createVirtualMachine(floodElementActual) {
    return new vm2_1.NodeVM({
        console: 'redirect',
        sandbox: {},
        require: {
            external: false,
            builtin: [],
            context: 'sandbox',
            mock: {
                '@flood/chrome': floodElementActual,
                '@flood/element': floodElementActual,
                faker: Faker,
                assert: nodeAssert,
            },
        },
    });
}
class EvaluatedScript {
    constructor(runEnv, script, lazyEval = false) {
        this.runEnv = runEnv;
        this.script = script;
        if (!lazyEval) {
            this.evaluate();
        }
    }
    // TestScriptErrorMapper implementation
    static async mustCompileFile(path, runEnv) {
        if (!(await exists(path))) {
            throw new Error(`unable to compile script: no script found at path ${path}`);
        }
        return new EvaluatedScript(runEnv, await TestScript_1.mustCompileFile(path));
    }
    isScriptError(error) {
        return this.script.isScriptError(error);
    }
    maybeLiftError(error) {
        return this.script.maybeLiftError(error);
    }
    liftError(error) {
        return this.script.liftError(error);
    }
    filterAndUnmapStack(stack) {
        return this.script.filterAndUnmapStack(stack);
    }
    bindTest(test) {
        if (this.vm === undefined)
            throw new Error('bindTest: no vm created - script must be evaluated first');
        const { reporter } = test;
        // hack because the vm2 typings don't include their EventEmitteryness
        let eevm = this.vm;
        ['log', 'info', 'error', 'dir', 'trace'].forEach(key => eevm.on(`console.${key}`, (message, ...args) => reporter.testScriptConsole(key, message, ...args)));
    }
    async beforeTestRun() {
        await this.testData.load();
    }
    get testDataLoaders() {
        if (this._testDataLoaders === undefined) {
            this._testDataLoaders = new TestDataLoaders_1.BoundTestDataLoaders(this, this.runEnv.workRoot);
            this._testDataLoaders.fromData([{}]);
        }
        return this._testDataLoaders;
    }
    set testData(testDataSource) {
        this._testData = testDataSource;
        this._testData.setInstanceID(this.sequence.toString());
    }
    get testData() {
        return this._testData;
    }
    get sequence() {
        return this.runEnv.stepEnv().SEQUENCE;
    }
    evaluate() {
        debug('evaluating');
        // Clear existing steps
        const steps = [];
        // establish base settings
        let rawSettings = Settings_1.DEFAULT_SETTINGS;
        const ENV = this.runEnv.stepEnv();
        // closes over steps: Step[]
        function captureStep(...args) {
            // name: string, fn: (driver: Browser) => Promise<void>
            let name;
            let fn;
            let stepOptions = {};
            if (args.length === 3) {
                ;
                [name, stepOptions, fn] = args;
                stepOptions = Step_1.normalizeStepOptions(stepOptions);
            }
            else {
                ;
                [name, fn] = args;
            }
            console.assert(typeof name === 'string', 'Step name must be a string');
            if (steps.find(({ name: stepName }) => name === stepName)) {
                console.warn(`Duplicate step name: ${name}, skipping step`);
                return;
            }
            steps.push({ fn, name, stepOptions });
        }
        // re-scope this for captureSuite to close over:
        const evalScope = this;
        // closes over evalScope (this) and ENV
        const captureSuite = Object.assign((callback) => {
            return callback;
        }, {
            withData: (data, callback) => {
                evalScope.testData = Expect_1.expect(data, 'TestData is not present');
                return callback;
            },
        });
        let context = {
            setup: (setupSettings) => {
                Object.assign(rawSettings, setupSettings);
            },
            ENV,
            // Supports either 2 or 3 args
            step: captureStep,
            // Actual implementation of @flood/chrome
            By: By_1.By,
            Until: Until_1.Until,
            Device: Enums_1.Device,
            MouseButtons: Enums_1.MouseButtons,
            TestData: this.testDataLoaders,
            Key: Enums_1.Key,
            userAgents: Enums_1.userAgents,
            suite: captureSuite,
            test() {
                throw new Error(`test() is no longer supported, please use 'export default suite(...)'`);
            },
        };
        this.vm = createVirtualMachine(context);
        // manually extract test name and desc from the script
        rawSettings.name = this.script.testName;
        rawSettings.description = this.script.testDescription;
        let result = this.vm.run(this.script.vmScript);
        debug('eval %O', result);
        // get settings exported from the script
        const scriptSettings = result.settings;
        if (scriptSettings) {
            rawSettings = Object.assign({}, rawSettings, scriptSettings);
        }
        let testFn = Expect_1.expect(result.default, 'Test script must export a default function');
        /**
         * Evaluate default function
         */
        testFn.apply(null, [captureStep]);
        // layer up the final settings
        this.settings = Object.assign({}, Settings_1.DEFAULT_SETTINGS, Settings_1.normalizeSettings(rawSettings));
        this.steps = steps;
        debug('settings', this.settings);
        debug('steps', this.steps);
        return this;
    }
}
exports.EvaluatedScript = EvaluatedScript;
