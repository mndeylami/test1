import { Condition } from '../page/Condition';
import { NavigationOptions, ClickOptions, Frame, Page, ScreenshotOptions } from 'puppeteer';
import { Browser as BrowserInterface, NullableLocatable, EvaluateFn } from './types';
import { Locator, ElementHandle } from '../page/types';
import { TargetLocator } from '../page/TargetLocator';
import { IPuppeteerClient } from '../driver/Puppeteer';
import { WorkRoot } from '../runtime-environment/types';
import { ConcreteTestSettings } from './Settings';
export declare function locatableToLocator(el: NullableLocatable, callCtx: string): Locator | never;
export declare const getFrames: (childFrames: Frame[]) => Frame[];
export declare class Browser<T> implements BrowserInterface {
    workRoot: WorkRoot;
    private client;
    settings: ConcreteTestSettings;
    beforeFunc: (b: Browser<T>, name: string) => Promise<void>;
    afterFunc: (b: Browser<T>, name: string) => Promise<void>;
    private activeFrame?;
    screenshots: string[];
    customContext: T;
    constructor(workRoot: WorkRoot, client: IPuppeteerClient, settings: ConcreteTestSettings, beforeFunc?: (b: Browser<T>, name: string) => Promise<void>, afterFunc?: (b: Browser<T>, name: string) => Promise<void>, activeFrame?: Frame | null | undefined);
    private readonly context;
    readonly target: Frame;
    readonly page: Page;
    readonly frames: Frame[];
    /**
     * Returns the URL of the current frame/page
     */
    readonly url: string;
    title(): Promise<string>;
    evaluate(fn: EvaluateFn, ...args: any[]): Promise<any>;
    authenticate(username?: string, password?: string): Promise<void>;
    wait(timeoutOrCondition: Condition | number): Promise<boolean>;
    visit(url: string, options?: NavigationOptions): Promise<void>;
    /**
     * Sends a click event to the element located at `selector`. If the element is
     * currently outside the viewport it will first scroll to that element.
     */
    click(selectorOrLocator: NullableLocatable, options?: ClickOptions): Promise<void>;
    /**
     * Sends a double-click event to the element located by the supplied Locator or `selector`. If the element is
     * currently outside the viewport it will first scroll to that element.
     */
    doubleClick(selectorOrLocator: NullableLocatable, options?: ClickOptions): Promise<void>;
    selectByValue(locatable: NullableLocatable, ...values: string[]): Promise<string[]>;
    selectByIndex(locatable: NullableLocatable, index: string): Promise<string[]>;
    selectByText(locatable: NullableLocatable, text: string): Promise<string[]>;
    clear(locatable: NullableLocatable | string): Promise<void>;
    type(locatable: NullableLocatable, text: string, options?: {
        delay: number;
    }): Promise<void>;
    press(keyCode: string, options?: {
        text?: string;
        delay?: number;
    }): Promise<void>;
    sendKeys(...keys: string[]): Promise<void>;
    blur(locatable: NullableLocatable): Promise<void>;
    focus(locatable: NullableLocatable): Promise<void>;
    clearBrowserCookies(): Promise<any>;
    clearBrowserCache(): Promise<any>;
    emulateDevice(deviceName: string): Promise<void>;
    setUserAgent(userAgent: string): Promise<void>;
    /**
     * Takes a screenshot of this element and saves it to the results folder with a random name.
     */
    takeScreenshot(options?: ScreenshotOptions): Promise<void>;
    highlightElement(element: ElementHandle): Promise<void>;
    findElement(locatable: NullableLocatable): Promise<ElementHandle>;
    maybeFindElement(locatable: NullableLocatable): Promise<ElementHandle | null>;
    findElements(locatable: NullableLocatable): Promise<ElementHandle[]>;
    set(key: string, value: string): Promise<void>;
    get(key: string): Promise<void>;
    extractText(locatable: NullableLocatable): Promise<string>;
    /**
     * Switch the focus of the browser to another frame or window
     */
    switchTo(): TargetLocator;
    performanceTiming(): Promise<PerformanceTiming>;
    navigationTiming(): Promise<PerformanceTiming>;
    /**
     * Fetches the paint performance timing entries
     */
    paintTiming(): Promise<PerformanceEntry[]>;
    waitForNavigation(): Promise<any>;
    interactionTiming(): Promise<number>;
    setCacheDisabled(cacheDisabled?: boolean): Promise<void>;
    fetchScreenshots(): string[];
    saveScreenshot(fn: (path: string) => Promise<boolean>): Promise<void>;
}
