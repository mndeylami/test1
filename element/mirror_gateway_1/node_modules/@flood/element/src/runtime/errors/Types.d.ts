import { StructuredError } from '../../utils/StructuredError';
export declare type ErrorInterpreter<T, U extends ErrorData> = (err: Error, target: T, key: string, ...args: any[]) => StructuredError<U> | undefined;
export declare type AnyErrorData = EmptyErrorData | NetworkErrorData | ActionErrorData | AssertionErrorData | LocatorErrorData | PuppeteerErrorData;
declare type ErrorDataKind = 'net' | 'action' | 'empty' | 'assertion' | 'locator' | 'puppeteer';
export interface ErrorData {
    _kind: ErrorDataKind;
}
export interface EmptyErrorData {
    _kind: 'empty';
}
export declare const emptyErrorData: {
    _kind: ErrorDataKind;
};
declare type NetworkErrorKind = 'net' | 'http';
export interface NetworkErrorData {
    _kind: 'net';
    kind: NetworkErrorKind;
    subKind: string;
    url: string;
    reason?: string;
    code?: string;
}
export declare type ActionErrorKind = 'wait-timeout' | 'node-detached';
export interface ActionErrorData {
    _kind: 'action';
    kind: ActionErrorKind;
    action: string;
}
export interface AssertionErrorData {
    _kind: 'assertion';
}
export interface LocatorErrorData {
    _kind: 'locator';
    kind: string;
    locator: string;
}
export declare type PuppeteerErrorKind = 'execution-context-destroyed' | 'evaluation-timeout';
export interface PuppeteerErrorData {
    _kind: 'puppeteer';
    kind: PuppeteerErrorKind;
}
export declare function interpretError<T, U extends ErrorData>(interpreters: ErrorInterpreter<T, U>[], inputError: Error, target: T, propertyKey: string, args: any[]): StructuredError<U> | Error;
export declare function castStructuredError<T extends ErrorData>(error: Error, kind: ErrorDataKind): StructuredError<T> | undefined;
export declare function getStructuredData<T extends ErrorData>(error: Error, kind: ErrorDataKind): T | undefined;
export {};
