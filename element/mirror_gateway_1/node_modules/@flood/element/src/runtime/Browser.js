"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const DeviceDescriptors = require("puppeteer/DeviceDescriptors");
const CustomDeviceDescriptors_1 = require("../utils/CustomDeviceDescriptors");
const TargetLocator_1 = require("../page/TargetLocator");
const By_1 = require("../page/By");
const path_1 = require("path");
const cuid = require("cuid");
const Enums_1 = require("../page/Enums");
const fs_1 = require("fs");
const termImg = require("term-img");
const Types_1 = require("./errors/Types");
const interpretPuppeteerError_1 = require("./errors/interpretPuppeteerError");
const StructuredError_1 = require("../utils/StructuredError");
const debugFactory = require("debug");
const debug = debugFactory('element:runtime:browser');
const debugScreenshot = debugFactory('element:runtime:browser:screenshot');
function toLocatorError(locatable, callContext) {
    let locatorString;
    if (locatable === null) {
        locatorString = 'null locator';
    }
    else if (typeof locatable === 'string') {
        locatorString = locatable;
    }
    else {
        locatorString = locatable.toErrorString();
    }
    return new StructuredError_1.StructuredError(`No element was found on the page using '${locatorString}'`, {
        _kind: 'locator',
        kind: 'element-not-found',
        locator: locatorString,
    }, undefined, 'browser', callContext);
}
function locatableToLocator(el, callCtx) {
    if (el === null) {
        throw toLocatorError(el, callCtx);
    }
    else if (typeof el === 'string') {
        return By_1.By.css(el);
    }
    else {
        // TODO proerly handle ElementHandle here...
        return el;
    }
}
exports.locatableToLocator = locatableToLocator;
exports.getFrames = (childFrames) => {
    let framesMap = new Map();
    for (const f of childFrames) {
        framesMap.set(f.name(), f);
        exports.getFrames(f.childFrames()).forEach(f => framesMap.set(f.name(), f));
    }
    return Array.from(framesMap.values());
};
/**
 * Defines a Function Decorator which wraps a method with class local before and after
 */
function addCallbacks() {
    const errorInterpreters = [interpretPuppeteerError_1.default];
    return function (target, propertyKey, descriptor) {
        let originalFn = descriptor.value;
        descriptor.value = async function (...args) {
            let ret;
            const browser = this;
            // capture the stack trace at call-time
            const calltimeError = new Error();
            Error.captureStackTrace(calltimeError);
            const calltimeStack = calltimeError.stack;
            try {
                if (browser.beforeFunc instanceof Function)
                    await browser.beforeFunc(browser, propertyKey);
                ret = await originalFn.apply(browser, args);
                if (browser.afterFunc instanceof Function)
                    await browser.afterFunc(browser, propertyKey);
            }
            catch (e) {
                debug('addCallbacks lifting to StructuredError', propertyKey, e);
                const newError = Types_1.interpretError(errorInterpreters, e, this, propertyKey, args);
                const sErr = StructuredError_1.StructuredError.liftWithSource(newError, 'browser', `browser.${propertyKey}`);
                sErr.stack = calltimeStack;
                debug('error now', sErr);
                throw sErr;
            }
            return ret;
        };
        return descriptor;
    };
}
function rewriteError() {
    const errorInterpreters = [interpretPuppeteerError_1.default];
    return function (target, propertyKey, descriptor) {
        let originalFn = descriptor.value;
        descriptor.value = async function (...args) {
            let ret;
            const browser = this;
            // capture the stack trace at call-time
            const calltimeError = new Error();
            Error.captureStackTrace(calltimeError);
            const calltimeStack = calltimeError.stack;
            try {
                ret = await originalFn.apply(browser, args);
            }
            catch (e) {
                debug('rewriteError lifting to StructuredError', propertyKey, e);
                const newError = Types_1.interpretError(errorInterpreters, e, this, propertyKey, args);
                const sErr = StructuredError_1.StructuredError.liftWithSource(newError, 'browser', `browser.${propertyKey}`);
                sErr.stack = calltimeStack;
                debug('error now', sErr);
                throw sErr;
            }
            return ret;
        };
        return descriptor;
    };
}
class Browser {
    constructor(workRoot, client, settings, beforeFunc = async () => { }, afterFunc = async () => { }, activeFrame) {
        this.workRoot = workRoot;
        this.client = client;
        this.settings = settings;
        this.beforeFunc = beforeFunc;
        this.afterFunc = afterFunc;
        this.activeFrame = activeFrame;
        this.beforeFunc && this.afterFunc;
        this.screenshots = [];
        // this.page.on('console', msg => console.log(msg))
    }
    get context() {
        // Promise.resolve is a quick fix for TS until the types are updated
        return Promise.resolve(this.target.executionContext());
    }
    get target() {
        if (this.activeFrame) {
            if (this.activeFrame.isDetached()) {
                this.activeFrame = null;
                throw new Error(`Frame is detached`);
            }
            else {
                return this.activeFrame;
            }
        }
        else {
            return this.page.mainFrame();
        }
    }
    get page() {
        return this.client.page;
    }
    get frames() {
        return exports.getFrames(this.page.frames());
    }
    /**
     * Returns the URL of the current frame/page
     */
    get url() {
        return this.page.url();
    }
    title() {
        return this.page.title();
    }
    async evaluate(fn, ...args) {
        return this.target.evaluate(fn, ...args);
    }
    async authenticate(username, password) {
        let authOptions = null;
        if (username !== undefined && password !== undefined) {
            authOptions = { username, password };
        }
        await this.page.authenticate(authOptions);
    }
    async wait(timeoutOrCondition) {
        if (typeof timeoutOrCondition === 'number') {
            await new Promise((yeah, nah) => setTimeout(yeah, Number(timeoutOrCondition) * 1e3));
            return true;
        }
        debug('wait');
        try {
            let condition = timeoutOrCondition;
            condition.settings = this.settings;
            if (condition.hasWaitFor) {
                return await condition.waitFor(this.target, this.page);
            }
            else {
                return await condition.waitForEvent(this.page);
            }
        }
        catch (err) {
            debug('wait timed out');
            throw new StructuredError_1.StructuredError('wait timed out', {
                _kind: 'action',
                kind: 'wait-timeout',
                action: 'wait',
            }, err);
        }
    }
    async visit(url, options = {}) {
        let timeout = this.settings.waitTimeout * 1e3;
        let response;
        try {
            response = await this.page.goto(url, Object.assign({ timeout, waitUntil: 'domcontentloaded' }, options));
        }
        catch (e) {
            if (e.message.includes('net::ERR_NAME_NOT_RESOLVED')) {
                e = new StructuredError_1.StructuredError('dns name not resolved', {
                    _kind: 'net',
                    url,
                    kind: 'net',
                    subKind: 'not-resolved',
                }, e);
            }
            if (e.message.includes('Navigation Timeout Exceeded')) {
                e = new StructuredError_1.StructuredError('navigation timed out', {
                    _kind: 'net',
                    url,
                    kind: 'net',
                    subKind: 'navigation-timeout',
                }, e);
            }
            throw e;
        }
        if (response === null) {
            throw new StructuredError_1.StructuredError('no response', {
                url,
                _kind: 'net',
                kind: 'http',
                subKind: 'no-response',
            });
        }
        // response needs to be 2xx or 3xx
        // TODO make configurable
        const status = response.status();
        if (!response.ok() && !(status >= 300 && status <= 399)) {
            throw new StructuredError_1.StructuredError('http response code not OK', {
                url,
                _kind: 'net',
                kind: 'http',
                subKind: 'not-ok',
                code: response.status().toString(),
            });
        }
        return;
    }
    /**
     * Sends a click event to the element located at `selector`. If the element is
     * currently outside the viewport it will first scroll to that element.
     */
    async click(selectorOrLocator, options) {
        const element = await this.findElement(selectorOrLocator);
        return element.click(options);
    }
    /**
     * Sends a double-click event to the element located by the supplied Locator or `selector`. If the element is
     * currently outside the viewport it will first scroll to that element.
     */
    async doubleClick(selectorOrLocator, options) {
        const element = await this.findElement(selectorOrLocator);
        return element.click(Object.assign({ clickCount: 2 }, options));
    }
    async selectByValue(locatable, ...values) {
        const element = await this.findElement(locatable);
        const context = await this.context;
        return context.evaluate((element, values) => {
            if (element.nodeName.toLowerCase() !== 'select')
                throw new Error('Element is not a <select> element.');
            const options = Array.from(element.options);
            element.value = '';
            for (const option of options)
                option.selected = values.includes(option.value);
            element.dispatchEvent(new Event('input', { bubbles: true }));
            element.dispatchEvent(new Event('change', { bubbles: true }));
            return options.filter(option => option.selected).map(option => option.value);
        }, element.element, values);
    }
    async selectByIndex(locatable, index) {
        // TODO: Write tests for this
        const element = await this.findElement(locatable);
        const context = await this.context;
        return context.evaluate((element, index) => {
            if (element.nodeName.toLowerCase() !== 'select')
                throw new Error('Element is not a <select> element.');
            const options = Array.from(element.options);
            element.value = '';
            element.selectedIndex = index;
            element.dispatchEvent(new Event('input', { bubbles: true }));
            element.dispatchEvent(new Event('change', { bubbles: true }));
            return options.filter(option => option.selected).map(option => option.value);
        }, element.element, index);
    }
    async selectByText(locatable, text) {
        const element = await this.findElement(locatable);
        const context = await this.context;
        return context.evaluate((element, text) => {
            if (element.nodeName.toLowerCase() !== 'select')
                throw new Error('Element is not a <select> element.');
            const options = Array.from(element.options);
            element.value = '';
            for (const option of options)
                option.selected = option.text === text || option.label === text;
            element.dispatchEvent(new Event('input', { bubbles: true }));
            element.dispatchEvent(new Event('change', { bubbles: true }));
            return options.filter(option => option.selected).map(option => option.value);
        }, element.element, text);
    }
    async clear(locatable) {
        let locator = locatableToLocator(locatable, 'browser.clear()');
        let elements = await locator.findMany(await this.context);
        for (const element of elements) {
            await element.clear();
        }
    }
    async type(locatable, text, options) {
        let element = await this.findElement(locatable);
        await element.focus();
        return this.page.keyboard.type(text, options);
    }
    async press(keyCode, options) {
        return this.page.keyboard.press(keyCode, options);
    }
    async sendKeys(...keys) {
        let handle = this.page.keyboard;
        for (const key of keys) {
            if (Object.values(Enums_1.Key).includes(key)) {
                await handle.press(key);
            }
            else {
                await handle.type(key);
            }
        }
    }
    async blur(locatable) {
        const element = await this.findElement(locatable);
        return element.blur();
    }
    async focus(locatable) {
        const element = await this.findElement(locatable);
        return element.focus();
    }
    async clearBrowserCookies() {
        const client = await this.page['target']().createCDPSession();
        await client.send('Network.clearBrowserCookies');
    }
    async clearBrowserCache() {
        const client = await this.page['target']().createCDPSession();
        await client.send('Network.clearBrowserCache');
    }
    async emulateDevice(deviceName) {
        let device = DeviceDescriptors[deviceName] || CustomDeviceDescriptors_1.default[deviceName];
        if (!device)
            throw new Error(`Unknown device descriptor: ${deviceName}`);
        return this.page.emulate(device);
    }
    async setUserAgent(userAgent) {
        return this.page.setUserAgent(userAgent);
    }
    /**
     * Takes a screenshot of this element and saves it to the results folder with a random name.
     */
    async takeScreenshot(options) {
        await this.saveScreenshot(async (path) => {
            await this.page.screenshot(Object.assign({ path }, options));
            return true;
        });
    }
    async highlightElement(element) {
        // let session = await this.page.target().createCDPSession()
        // session.send('DOM.highlightNode', { nodeId: element })
        return element.highlight();
    }
    async findElement(locatable) {
        let locator = locatableToLocator(locatable, 'browser.findElement(locatable)');
        debug('locator %o', locator);
        let maybeElement = await locator.find(await this.context);
        if (!maybeElement) {
            throw toLocatorError(locatable, 'browser.findElement()');
        }
        const element = maybeElement;
        element.bindBrowser(this);
        return element;
    }
    async maybeFindElement(locatable) {
        if (locatable === null) {
            return null;
        }
        const locator = locatableToLocator(locatable, 'browser.maybeFindElement(locatable)');
        const context = await this.context;
        let maybeElement = await locator.find(context);
        if (!maybeElement)
            return null;
        const element = maybeElement;
        element.bindBrowser(this);
        return element;
    }
    async findElements(locatable) {
        let locator = locatableToLocator(locatable, 'browser.findElemts(locatable)');
        let elements = await locator.findMany(await this.context);
        elements.forEach(element => element.bindBrowser(this));
        return elements;
    }
    async set(key, value) { }
    async get(key) { }
    async extractText(locatable) {
        console.warn(`DEPRECATED: Driver.extractText() is deprecated, please use ElementHandle.text()`);
        let locator = locatableToLocator(locatable, 'browser.extractText(locatable) (DEPRECATED)');
        let element = await locator.find(await this.context);
        if (!element)
            throw toLocatorError(locatable, 'browser.extractText()');
        return element.text();
    }
    /**
     * Switch the focus of the browser to another frame or window
     */
    switchTo() {
        return new TargetLocator_1.TargetLocator(this.page, frame => {
            this.activeFrame = frame;
        });
    }
    async performanceTiming() {
        return this.page.evaluate(() => performance.timing.toJSON());
    }
    async navigationTiming() {
        let data = await this.page.evaluate(() => JSON.stringify(window.performance.timing));
        return JSON.parse(data.toString());
    }
    /**
     * Fetches the paint performance timing entries
     */
    async paintTiming() {
        let data = await this.page.evaluate(() => JSON.stringify(window.performance.getEntriesByType('paint')));
        return JSON.parse(data.toString());
    }
    async waitForNavigation() {
        return this.page.waitForNavigation({ waitUntil: 'domcontentloaded' });
    }
    // TODO fix this
    async interactionTiming() {
        try {
            let polyfill = fs_1.readFileSync(path_1.resolve(path_1.join(__dirname, '../extern/tti-polyfill-debug.js')), 'utf8');
            await this.target.evaluate(polyfill);
            return await this.target.evaluate('window.ttiPolyfill.getFirstConsistentlyInteractive()');
        }
        catch (e) {
            console.warn('error getting interaction timing:', e);
            return 0;
        }
    }
    async setCacheDisabled(cacheDisabled = true) {
        const client = await this.page['target']().createCDPSession();
        await client.send('Network.setCacheDisabled', { cacheDisabled });
    }
    fetchScreenshots() {
        let screenshots = [...this.screenshots];
        this.screenshots = [];
        return screenshots;
    }
    async saveScreenshot(fn) {
        const path = this.workRoot.join('screenshots', `${cuid()}.jpg`);
        debugScreenshot(`Saving screenshot to: ${path}`);
        if (await fn(path)) {
            this.screenshots.push(path);
            debugScreenshot(`Saved screenshot to: ${path}`);
            termImg(path, {
                width: '40%',
                fallback: () => {
                    return `Screenshot path: ${path}`;
                },
            });
        }
    }
}
__decorate([
    rewriteError(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Browser.prototype, "title", null);
__decorate([
    rewriteError(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], Browser.prototype, "evaluate", null);
__decorate([
    rewriteError(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], Browser.prototype, "authenticate", null);
__decorate([
    addCallbacks(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Browser.prototype, "wait", null);
__decorate([
    addCallbacks(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], Browser.prototype, "visit", null);
__decorate([
    addCallbacks(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], Browser.prototype, "click", null);
__decorate([
    addCallbacks(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], Browser.prototype, "doubleClick", null);
__decorate([
    addCallbacks(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String]),
    __metadata("design:returntype", Promise)
], Browser.prototype, "selectByValue", null);
__decorate([
    addCallbacks(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String]),
    __metadata("design:returntype", Promise)
], Browser.prototype, "selectByIndex", null);
__decorate([
    addCallbacks(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String]),
    __metadata("design:returntype", Promise)
], Browser.prototype, "selectByText", null);
__decorate([
    addCallbacks(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Browser.prototype, "clear", null);
__decorate([
    addCallbacks(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, String, Object]),
    __metadata("design:returntype", Promise)
], Browser.prototype, "type", null);
__decorate([
    addCallbacks(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, Object]),
    __metadata("design:returntype", Promise)
], Browser.prototype, "press", null);
__decorate([
    addCallbacks(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], Browser.prototype, "sendKeys", null);
__decorate([
    addCallbacks(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Browser.prototype, "blur", null);
__decorate([
    addCallbacks(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Browser.prototype, "focus", null);
__decorate([
    rewriteError(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Browser.prototype, "clearBrowserCookies", null);
__decorate([
    rewriteError(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Browser.prototype, "clearBrowserCache", null);
__decorate([
    rewriteError(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], Browser.prototype, "emulateDevice", null);
__decorate([
    rewriteError(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], Browser.prototype, "setUserAgent", null);
__decorate([
    rewriteError(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Browser.prototype, "takeScreenshot", null);
__decorate([
    rewriteError(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Browser.prototype, "highlightElement", null);
__decorate([
    rewriteError(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Browser.prototype, "findElement", null);
__decorate([
    rewriteError(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Browser.prototype, "findElements", null);
__decorate([
    rewriteError(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], Browser.prototype, "extractText", null);
exports.Browser = Browser;
