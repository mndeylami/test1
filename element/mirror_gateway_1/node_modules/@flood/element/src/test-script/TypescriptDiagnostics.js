"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = require("typescript");
const ts = require("typescript");
function categoryMap(d) {
    switch (d) {
        case typescript_1.DiagnosticCategory.Error:
            return 'errors';
        case typescript_1.DiagnosticCategory.Warning:
            return 'warnings';
        case typescript_1.DiagnosticCategory.Message:
            return 'messages';
        default:
            throw new Error(`unknown diagnostic category ${d}`);
    }
}
class CategorisedDiagnostics {
    constructor(formatHost, filenameMapper) {
        this.formatHost = formatHost;
        this.filenameMapper = filenameMapper;
        this.diagnostics = { errors: [], warnings: [], messages: [] };
    }
    has(kind) {
        return this.forCategory(kind).length > 0;
    }
    hasNonErrors() {
        return this.has('messages') || this.has('warnings');
    }
    hasOnlyNonErrors() {
        return !this.has('errors') && this.hasNonErrors();
    }
    add(d) {
        this.forCategory(categoryMap(d.category)).push(d);
    }
    forCategory(kind) {
        return this.diagnostics[kind];
    }
    formattedForCategory(kind) {
        const diagnostics = this.forCategory(kind).map(d => {
            if (d.file) {
                d.file.fileName = this.filenameMapper(d.file.fileName);
            }
            return d;
        });
        return ts.formatDiagnosticsWithColorAndContext(diagnostics, this.formatHost);
    }
    stringForCategory(kind, delim = '\n') {
        return this.format(kind).join(delim);
    }
    format(kind) {
        return this.forCategory(kind).map(d => this.formatDiagnostic(d));
    }
    formatDiagnostic(diagnostic) {
        if (diagnostic.file) {
            const { line, character } = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start);
            const message = ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n');
            return `${diagnostic.file.fileName} (${line + 1},${character + 1}): ${message}`;
        }
        else {
            return `${ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n')}`;
        }
    }
}
exports.CategorisedDiagnostics = CategorisedDiagnostics;
