"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const TestScript_1 = require("../TestScript");
const TypescriptDiagnostics_1 = require("./TypescriptDiagnostics");
const ts = require("typescript");
const path = require("path");
const fs_1 = require("fs");
// import { existsSync, readFileSync } from 'fs'
const vm2_1 = require("vm2");
const parseComments = require("comment-parser");
const SourceUnmapper_1 = require("./SourceUnmapper");
const debugFactory = require("debug");
const os_1 = require("os");
const findRoot = require("find-root");
const manualModuleDefinition_1 = require("./manualModuleDefinition");
const os = require("os");
const debug = debugFactory('element:test-script:compiler');
const floodelementRoot = findRoot(__dirname);
const sandboxPath = 'test-script-sandbox';
const sandboxRoot = path.join(os_1.tmpdir(), 'flood-element-tmp', sandboxPath);
const sandboxedBasenameTypescript = 'flood-chrome.ts';
const sandboxedBasenameJavascript = 'flood-chrome.js';
// handle e.g. during dev/test vs built/dist mode
let indexModuleFile;
const indexTypescriptFile = path.join(floodelementRoot, 'index.ts');
const indexDeclarationsFile = path.join(floodelementRoot, 'index.d.ts');
const ambientDeclarationsFile = path.join(floodelementRoot, 'ambient.d.ts');
if (fs_1.existsSync(indexTypescriptFile)) {
    indexModuleFile = indexTypescriptFile;
}
else if (fs_1.existsSync(indexDeclarationsFile)) {
    indexModuleFile = indexDeclarationsFile;
}
else {
    throw new Error('unable to find index.ts or index.d.ts');
}
const indexModuleDefinition = {
    resolvedFileName: indexModuleFile,
    isExternalLibraryImport: true,
};
const manualModuleDefinitions = {
    '@flood/chrome': indexModuleDefinition,
    '@flood/element': indexModuleDefinition,
    faker: manualModuleDefinition_1.manualModuleDefinition('@types/faker'),
};
const manualTypeResolutions = {
    faker: manualModuleDefinition_1.manualModuleResolution('@types/faker'),
};
const win32 = os.platform() === 'win32';
function tsFilename(infile) {
    if (win32) {
        return infile.replace(/\\/g, '/');
    }
    return infile;
}
const NoModuleImportedTypescript = `Test scripts must import the module '@flood/element'
Please add an import as follows:

import { suite } from '@flood/element'
`;
const NoModuleImportedJavascript = `Test scripts must import the module '@flood/element'
Please add an import as follows:

import { suite } from '@flood/element'
`;
const FloodChromeErrors = {
    NoModuleImportedTypescript,
    NoModuleImportedJavascript,
};
const defaultCompilerOptions = {
    noEmitOnError: true,
    noImplicitAny: false,
    strictNullChecks: false,
    noUnusedParameters: false,
    noUnusedLocals: false,
    allowSyntheticDefaultImports: true,
    experimentalDecorators: true,
    allowJs: true,
    checkJs: true,
    suppressOutputPathCheck: true,
    sourceMap: true,
    // tracing useful for our debugging
    traceResolution: false,
    rootDirs: [sandboxRoot],
    module: ts.ModuleKind.CommonJS,
    moduleResolution: ts.ModuleResolutionKind.NodeJs,
    target: ts.ScriptTarget.ES2017,
    pretty: true,
    lib: [
        'lib.dom.d.ts',
        'lib.dom.iterable.d.ts',
        'lib.es2017.d.ts',
        'lib.es2016.array.include.d.ts',
        'lib.es2017.object.d.ts',
    ],
    // types: ['@types/node'],
    typeRoots: ['node_modules/@types'],
    baseUrl: './',
    paths: { '*': ['node_modules/@types/*', '*'] },
};
class TypeScriptTestScript {
    constructor(originalSource, originalFilename, options = TestScript_1.TestScriptDefaultOptions) {
        this.originalSource = originalSource;
        this.originalFilename = originalFilename;
        this.floodChromeErrors = [];
        this.testScriptOptions = Object.assign({}, TestScript_1.TestScriptDefaultOptions, options);
        if (this.originalFilename.endsWith('.js')) {
            this.sourceKind = 'javascript';
            this.sandboxedBasename = sandboxedBasenameJavascript;
        }
        else {
            this.sourceKind = 'typescript';
            this.sandboxedBasename = sandboxedBasenameTypescript;
        }
        this.sandboxedFilename = path.join(sandboxRoot, this.sandboxedBasename);
        this.sandboxedRelativeFilename = path.join(sandboxPath, this.sandboxedBasename);
    }
    get hasErrors() {
        return this.floodChromeErrors.length > 0 || this.diagnostics.has('errors');
    }
    get formattedErrorString() {
        let errors = [];
        if (this.floodChromeErrors.length > 0) {
            errors = errors.concat(this.floodChromeErrors);
        }
        if (this.diagnostics) {
            errors.push(this.diagnostics.formattedForCategory('errors'));
        }
        return errors.join('\n');
    }
    get compilerOptions() {
        const compilerOptions = Object.assign({}, defaultCompilerOptions);
        if (this.testScriptOptions.stricterTypeChecking) {
            compilerOptions.strictNullChecks = true;
            compilerOptions.noImplicitAny = true;
        }
        if (this.testScriptOptions.traceResolution || debug.enabled) {
            compilerOptions.traceResolution = true;
        }
        return compilerOptions;
    }
    async compile() {
        if (!this.isFloodElementCorrectlyImported) {
            switch (this.sourceKind) {
                case 'javascript':
                    this.floodChromeErrors.push(FloodChromeErrors.NoModuleImportedJavascript);
                    break;
                case 'typescript':
                    this.floodChromeErrors.push(FloodChromeErrors.NoModuleImportedTypescript);
                    break;
            }
            return this;
        }
        // debugger
        // const sandboxedBasename = this.sandboxedBasename
        const sandboxedFilename = this.sandboxedFilename;
        const inputSource = this.originalSource;
        const compilerOptions = this.compilerOptions;
        const host = ts.createCompilerHost(compilerOptions);
        const outputFiles = [];
        host.writeFile = function (name, text, writeByteOrderMark) {
            outputFiles.push({ name, text, writeByteOrderMark });
        };
        const tsSandboxedFilename = tsFilename(sandboxedFilename);
        const originalGetSourceFile = host.getSourceFile;
        host.getSourceFile = function (fileName, languageVersion, onError) {
            debug('getSourceFile', fileName);
            // inject our source string if its the sandboxedBasename
            if (fileName === tsSandboxedFilename) {
                return ts.createSourceFile(fileName, inputSource, languageVersion, false);
            }
            else {
                return originalGetSourceFile.apply(this, arguments);
            }
        };
        const moduleResolutionCache = ts.createModuleResolutionCache(host.getCurrentDirectory(), x => host.getCanonicalFileName(x));
        host.resolveModuleNames = function (moduleNames, containingFile) {
            const resolvedModules = [];
            for (let moduleName of moduleNames) {
                debug('resolve', moduleName);
                let result = manualModuleDefinitions[moduleName];
                if (result === undefined) {
                    result = ts.resolveModuleName(moduleName, containingFile, compilerOptions, host, moduleResolutionCache).resolvedModule; // original-TODO: GH#18217
                }
                resolvedModules.push(result);
            }
            return resolvedModules;
        };
        host.resolveTypeReferenceDirectives = (typeReferenceDirectiveNames, containingFile) => {
            debug('resolveTypeReferenceDirectives', typeReferenceDirectiveNames, containingFile);
            return typeReferenceDirectiveNames
                .map(typeRef => {
                let typeResolution = manualTypeResolutions[typeRef];
                if (typeResolution === undefined) {
                    typeResolution = ts.resolveTypeReferenceDirective(typeRef, containingFile, compilerOptions, host).resolvedTypeReferenceDirective;
                }
                return typeResolution;
            })
                .map(t => {
                debug('resolution', t);
                return t;
            });
        };
        const program = ts.createProgram([ambientDeclarationsFile, this.sandboxedFilename], compilerOptions, host);
        const emitResult = program.emit();
        this.diagnostics = new TypescriptDiagnostics_1.CategorisedDiagnostics(host, this.filenameMapper.bind(this));
        // sortAndDeduplicateDiagnostics when its released
        let allDiagnostics = ts.getPreEmitDiagnostics(program).concat(emitResult.diagnostics);
        allDiagnostics = ts.sortAndDeduplicateDiagnostics(allDiagnostics);
        allDiagnostics.forEach(diagnostic => this.diagnostics.add(diagnostic));
        if (emitResult.emitSkipped) {
            return this;
        }
        console.assert(outputFiles.length == 2, 'There should only be two output files');
        this.source = (outputFiles.find(f => f.name.endsWith('.js')) || { text: '' }).text;
        this.sourceMap = (outputFiles.find(f => f.name.endsWith('.js.map')) || { text: '' }).text;
        this.sourceUnmapper = await SourceUnmapper_1.SourceUnmapper.init(this.originalSource, this.originalFilename, this.sourceMap);
        return this;
    }
    filenameMapper(filename) {
        if (filename == this.sandboxedFilename || filename == this.sandboxedBasename) {
            return this.originalFilename;
        }
        else {
            return filename;
        }
    }
    get vmScript() {
        if (!this.vmScriptMemo) {
            this.vmScriptMemo = new vm2_1.VMScript(this.source, this.sandboxedFilename);
        }
        return this.vmScriptMemo;
    }
    get isFloodElementCorrectlyImported() {
        return (this.originalSource.includes('@flood/chrome') ||
            this.originalSource.includes('@flood/element'));
    }
    get testName() {
        return this.parsedComments('name');
    }
    get testDescription() {
        return this.parsedComments('description');
    }
    parsedComments(key) {
        if (!this.parsedCommentsMemo) {
            let comments = parseComments(this.originalSource);
            let description = '', name = '';
            if (comments.length) {
                let { description: body } = comments[0];
                let [line1, ...lines] = body.split('\n');
                name = line1;
                description = lines
                    .filter((l) => l.length)
                    .join('\n')
                    .trim();
            }
            this.parsedCommentsMemo = { name, description };
        }
        return this.parsedCommentsMemo[key];
    }
    isScriptError(error) {
        const stack = error.stack || '';
        return stack.split('\n').filter(s => s.includes(this.sandboxedFilename)).length > 0;
    }
    liftError(error) {
        const stack = error.stack || '';
        const filteredStack = stack.split('\n').filter(s => s.includes(this.sandboxedFilename));
        let callsite;
        let unmappedStack = [];
        if (filteredStack.length > 0) {
            callsite = this.sourceUnmapper.unmapCallsite(filteredStack[0]);
            unmappedStack = this.sourceUnmapper.unmapStackNodeStrings(filteredStack);
        }
        return new TestScript_1.TestScriptError(error.message, stack, callsite, unmappedStack, error);
    }
    maybeLiftError(error) {
        if (this.isScriptError(error)) {
            return this.liftError(error);
        }
        else {
            return error;
        }
    }
    filterAndUnmapStack(input) {
        let stack;
        if (input === undefined) {
            return [];
        }
        else if (typeof input === 'string') {
            stack = input;
        }
        else {
            const maybeStack = input.stack;
            if (maybeStack === undefined) {
                return [];
            }
            else {
                stack = maybeStack;
            }
        }
        const filteredStack = stack.split('\n').filter(s => s.includes(this.sandboxedFilename));
        return this.sourceUnmapper.unmapStackNodeStrings(filteredStack);
    }
}
exports.TypeScriptTestScript = TypeScriptTestScript;
