"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const source_map_1 = require("source-map");
function callsiteToString(callsite) {
    if (callsite) {
        return (callsite.file +
            ':' +
            callsite.line +
            '\n' +
            callsite.code +
            '\n' +
            new Array(callsite.column).join(' ') +
            '^');
    }
    return '';
}
exports.callsiteToString = callsiteToString;
// inspiration from:
// https://github.com/evanw/node-source-map-support
class SourceUnmapper {
    constructor(originalSource, originalFilename, sourceMapConsumer) {
        this.originalSource = originalSource;
        this.originalFilename = originalFilename;
        this.sourceMapConsumer = sourceMapConsumer;
    }
    // can't have async constructors, so:
    static async init(originalSource, originalFilename, sourceMap) {
        const sourceMapConsumer = await new source_map_1.SourceMapConsumer(sourceMap);
        return new SourceUnmapper(originalSource, originalFilename, sourceMapConsumer);
    }
    unmapNodeStackLine(stackLine) {
        return callsiteToString(this.unmapCallsite(stackLine));
    }
    unmapCallsite(stackLine) {
        const match = /\s+at [^(]+ \((.*?):(\d+):(\d+)\)/.exec(stackLine);
        if (match) {
            const pos = { source: match[1], line: +match[2], column: +match[3] };
            const originalPos = this.sourceMapConsumer.originalPositionFor(pos);
            if (originalPos.line === null || originalPos.column == null) {
                return undefined;
            }
            const code = this.extractSourceLine(originalPos.line);
            return {
                file: this.originalFilename,
                code: code,
                line: originalPos.line,
                column: originalPos.column,
            };
        }
        else {
            return undefined;
        }
    }
    unmapStack(stack) {
        return this.parseStack(stack)
            .map(s => this.originalPositionFor(s))
            .filter((x) => x !== undefined);
    }
    // XXX Error.prepareStackTrace
    parseStack(stack) {
        // const tapp = tag => x => {
        // debug(tag, x)
        // return x
        // }
        return stack
            .map(s => /\s+at ([^(]+) \((.*?):(\d+):(\d+)\)/.exec(s))
            .filter((x) => x !== null)
            .filter(x => {
            return x && x[1] && x[2] && x[3] && x[4];
        })
            .map(match => ({ at: match[1], file: match[2], line: +match[3], column: +match[4] }));
    }
    originalPositionFor(pos) {
        const originalPos = this.sourceMapConsumer.originalPositionFor({
            line: pos.line,
            column: pos.column,
        });
        if (originalPos.line === null || originalPos.column === null) {
            return undefined;
        }
        return {
            at: pos.at,
            file: this.originalFilename,
            line: originalPos.line,
            column: originalPos.column,
        };
    }
    unmapStackNodeStrings(stack) {
        const unmapped = this.unmapStack(stack);
        return unmapped.map(this.stackLineToNodeString);
    }
    extractSourceLine(line) {
        return this.originalSource.split(/(?:\r\n|\r|\n)/)[line - 1];
    }
    stackLineToNodeString(m) {
        return `    at ${m.at} ${m.file}:${m.line}:${m.column}`;
    }
}
exports.SourceUnmapper = SourceUnmapper;
