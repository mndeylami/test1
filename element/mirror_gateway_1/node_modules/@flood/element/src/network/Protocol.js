"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class Entry {
    constructor(attrs = {}) {
        this.request = new EntryRequest();
        this.response = new EntryResponse();
        Object.assign(this, attrs);
        // let k: keyof this
        // let v: any
        // for (let [k, v] of Object.entries(attrs)) {
        // this.set(k, v)
        // // this[k: keyof this] = v
        // }
    }
    toJSON() {
        return {
            requestId: this.requestId,
            startedDateTime: this.startedDateTime,
            time: this.time,
            type: this.type,
            request: this.request.toJSON(),
            response: this.response.toJSON(),
            cache: this.cache,
            timings: this.timings,
            serverIPAddress: this.serverIPAddress,
            connection: this.connection,
            pageref: this.pageref,
        };
    }
}
exports.Entry = Entry;
class EntryRequest {
    constructor() {
        this._epoch = -1;
        this._issueTime = -1;
        this._wallIssueTime = -1;
        this._startTime = -1;
        this._endTime = -1;
        this._ttfb = -1;
        this._responseReceivedTime = -1;
        this._timing = {};
    }
    setIssueTime(monotonicTime, wallTime) {
        this._issueTime = monotonicTime;
        this._wallIssueTime = wallTime;
        this._startTime = monotonicTime;
    }
    /**
     * @param {number} monotonicTime
     * @return {number}
     */
    pseudoWallTime(monotonicTime) {
        return this._wallIssueTime
            ? this._wallIssueTime - this._issueTime + monotonicTime
            : monotonicTime;
    }
    /**
     * @param {!Protocol.Network.ResourceTiming|undefined} timingInfo
     */
    set timing(timingInfo) {
        if (!timingInfo)
            return;
        // Take startTime and responseReceivedTime from timing data for better accuracy.
        // Timing's requestTime is a baseline in seconds, rest of the numbers there are ticks in millis.
        this._startTime = timingInfo.requestTime * 1e3;
        var headersReceivedTime = timingInfo.requestTime * 1e3 + timingInfo.receiveHeadersEnd;
        if ((this._responseReceivedTime || -1) < 0 || this._responseReceivedTime > headersReceivedTime)
            this._responseReceivedTime = headersReceivedTime;
        if (this._startTime > this._responseReceivedTime)
            this._responseReceivedTime = this._startTime;
        this._ttfb = timingInfo.receiveHeadersEnd - timingInfo.sendEnd;
        this._timing = timingInfo;
    }
    get timing() {
        return this._timing;
    }
    /**
     * @return {number}
     */
    get endTime() {
        return this._endTime || -1;
    }
    /**
     * @param {number} x
     */
    set endTime(x) {
        if (this.timing && this.timing.requestTime) {
            // Check against accurate responseReceivedTime.
            this._endTime = Math.max(x, this._responseReceivedTime);
        }
        else {
            // Prefer endTime since it might be from the network stack.
            this._endTime = x;
            if (this._responseReceivedTime > x)
                this._responseReceivedTime = x;
        }
    }
    /**
     * @return {number}
     */
    get duration() {
        if (this._endTime === -1 || this._startTime === -1)
            return -1;
        return this._endTime - this._startTime;
    }
    /**
     * @return {number}
     */
    get latency() {
        if (this._responseReceivedTime === -1 || this._startTime === -1)
            return -1;
        return this._responseReceivedTime - this._startTime;
    }
    get ttfb() {
        return this._ttfb || -1;
    }
    toJSON() {
        return {
            timestamp: this.timestamp,
            method: this.method,
            url: this.url,
            httpVersion: this.httpVersion,
            headers: this.headers,
            queryString: this.queryString,
            headersSize: this.headersSize,
            bodySize: this.bodySize,
            cookies: this.cookies,
        };
    }
}
exports.EntryRequest = EntryRequest;
class EntryResponse {
    toJSON() {
        return {
            timestamp: this.timestamp,
            status: this.status,
            statusText: this.statusText,
            httpVersion: this.httpVersion,
            headers: this.headers,
            redirectURL: this.redirectURL,
            headersSize: this.headersSize,
            bodySize: this.bodySize,
            _transferSize: this._transferSize,
            cookies: this.cookies,
            content: this.content,
        };
    }
}
exports.EntryResponse = EntryResponse;
class Page {
    toJSON() {
        return {
            startedDateTime: this.startedDateTime,
            id: this.id,
            title: this.title,
            pageTimings: this.pageTimings,
        };
    }
}
exports.Page = Page;
