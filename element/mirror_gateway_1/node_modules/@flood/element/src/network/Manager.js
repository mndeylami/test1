"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class Manager {
    constructor(page, requestIdToRequest = new Map()) {
        this.page = page;
        this.requestIdToRequest = requestIdToRequest;
        this.timeout = 10e3;
        this.attachEvents();
    }
    async getIdlePromise() {
        console.log('get idle promise');
        this.createIdlePromise();
        return this.networkIdlePromise;
    }
    get pendingRequestCount() {
        return this.requestIdToRequest.size;
    }
    updateIdlePromise() {
        if (this.pendingRequestCount <= 2 && this.lifecycleCompleteCallback) {
            this.lifecycleCompleteCallback.apply(this);
            this.networkIdlePromise = null;
            this.lifecycleCompleteCallback = null;
            console.log(`Idle promise callback fired`);
        }
    }
    createTimeoutPromise() {
        return new Promise(fulfill => (this.maximumTimer = setTimeout(fulfill, this.timeout)));
    }
    createIdlePromise() {
        if (this.lifecycleCompleteCallback)
            return;
        if (this.networkIdlePromise)
            return;
        const lifecycleCompletePromise = new Promise(fulfill => {
            this.lifecycleCompleteCallback = fulfill;
        });
        this.networkIdlePromise = Promise.race([lifecycleCompletePromise, this.createTimeoutPromise()]);
        this.updateIdlePromise();
    }
    attachEvents() {
        const client = this.page['_client'];
        client.on('Network.requestWillBeSent', this.onRequestWillBeSent.bind(this));
        client.on('Network.requestIntercepted', this.onRequestIntercepted.bind(this));
        client.on('Network.responseReceived', this.onResponseReceived.bind(this));
        client.on('Network.loadingFinished', this.onLoadingFinished.bind(this));
        client.on('Network.loadingFailed', this.onLoadingFailed.bind(this));
    }
    onRequestWillBeSent(event) {
        if (event.redirectResponse) {
        }
        this.handleRequestStart(event.requestId, event.request.url, event.type, event.request, event.frameId);
    }
    handleRequestStart(requestId, url, resourceType, requestPayload, frameId) {
        if (requestId)
            this.requestIdToRequest.set(requestId, null);
    }
    onRequestIntercepted() {
        console.log('RequestIntercepted');
        this.updateIdlePromise();
    }
    onResponseReceived() {
        this.updateIdlePromise();
    }
    onLoadingFinished(event) {
        // const request = this.requestIdToRequest.get(event.requestId)
        this.requestIdToRequest.delete(event.requestId);
        this.updateIdlePromise();
        // console.log(`Pending requests: ${this.pendingRequestCount}`)
    }
    onLoadingFailed(event) {
        const request = this.requestIdToRequest.get(event.requestId);
        // For certain requestIds we never receive requestWillBeSent event.
        // @see https://crbug.com/750469
        if (!request)
            return;
        this.requestIdToRequest.delete(event.requestId);
        this.updateIdlePromise();
    }
}
exports.Manager = Manager;
