/// <reference types="node" />
import { ResourceType, Page as PuppeteerPage, PageEvents } from 'puppeteer';
import { Entry, RawResponse, Page } from './Protocol';
import { AsyncQueue } from '../utils/AsyncQueue';
import { Manager } from './Manager';
export default class Recorder {
    page: PuppeteerPage;
    entries: Entry[];
    private pages;
    pendingTaskQueue: AsyncQueue<any>;
    manager: Manager;
    constructor(page: PuppeteerPage);
    toJSON(): {
        log: {
            version: string;
            creator: {
                name: string;
                version: string;
            };
            pages: Page[];
            entries: {
                requestId: string;
                startedDateTime: Date;
                time: number;
                type: string;
                request: {
                    timestamp: number;
                    method: string;
                    url: string;
                    httpVersion: string;
                    headers: {
                        name: string;
                        value: string;
                    }[];
                    queryString: string[];
                    headersSize: number;
                    bodySize: null;
                    cookies: {
                        name: string;
                        value: string;
                        expires: string | null;
                        httpOnly: boolean;
                        secure: boolean;
                    }[];
                };
                response: {
                    timestamp: number;
                    status: number;
                    statusText: string;
                    httpVersion: string;
                    headers: {
                        name: string;
                        value: string;
                    }[];
                    redirectURL: string;
                    headersSize: number;
                    bodySize: number;
                    _transferSize: number;
                    cookies: {
                        name: string;
                        value: string;
                        expires: string | null;
                        httpOnly: boolean;
                        secure: boolean;
                        path: string;
                    }[];
                    content: {
                        size: number;
                        mimeType: string;
                        compression?: number | undefined;
                        text: string;
                    };
                };
                cache: {};
                timings: {
                    blocked: number;
                    dns: number;
                    ssl: number;
                    connect: number;
                    send: number;
                    wait: number;
                    receive: number;
                    _blocked_queueing: number;
                };
                serverIPAddress: string;
                connection: string;
                pageref: string;
            }[];
        };
    };
    sync(): Promise<void>;
    recordRequest(payload: any): Promise<void>;
    recordResponse(payload: RawResponse): Promise<void>;
    recordResponseCompleted({ requestId, encodedDataLength, timestamp, }: {
        requestId: string;
        encodedDataLength: number;
        timestamp: number;
    }): Promise<void>;
    /**
     * Returns the recorded entries for the given Document Type
     *
     * @param {string} documentType
     * @returns {Entry[]}
     * @memberof NetworkRecorder
     */
    entriesForType(documentType: string): Entry[];
    /**
     * Returns the response code for the last document request
     *
     * @readonly
     * @type {number}
     * @memberof NetworkRecorder
     */
    readonly documentResponseCode: number;
    entriesForPage(page: Page): Entry[];
    entriesForPage(pageId: string): Entry[];
    /**
     * Returns total network throuhgput for a specific response type
     * @param  {ResourceType} type
     * @return {number}
     */
    networkThroughputByType(type: ResourceType): number;
    /**
     * Returns the total network throughput for all requests
     *
     * @returns {number}
     * @memberof NetworkRecorder
     */
    networkThroughput(): number;
    responseTime(): number;
    meanResponseTime(): number;
    responseTimeForType(type: string): number;
    latencyForType(type: string): number;
    timeToFirstByteForType(type: string): number;
    reset(): void;
    addPendingTask(promise: Promise<any>): void;
    recordDOMContentLoadedEvent(): void;
    /**
     * Attaches an event to the Pupeteer page or internal client
     *
     * @param {(puppeteer.PageEvents | string)} pageEvent
     * @param {(event: any) => void} handler
     */
    attachEvent(pageEvent: string | PageEvents, handler: (event: any) => void): void;
    private recordPageResponse;
    private getEntryForRequestId;
    private privateClientSend;
    getResponseData(requestId: string): Promise<Buffer>;
}
