"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const Compiler_1 = require("./test-script/Compiler");
const SourceUnmapper_1 = require("./test-script/SourceUnmapper");
function originalError(e) {
    if (e.originalError !== undefined) {
        return originalError(e.originalError);
    }
    else {
        return e;
    }
}
class TestScriptError extends Error {
    constructor(message, originalStack, callsite, unmappedStack, originalError) {
        super(message);
        this.callsite = callsite;
        this.unmappedStack = unmappedStack;
        this.originalError = originalError;
        this.stackWhenThrown = this.stack || '';
        this.stack = originalStack;
        this.message = message;
    }
    get hasDoc() {
        return this.originalError.errorDoc !== undefined;
    }
    get errorDoc() {
        if (this.originalError.errorDoc !== undefined) {
            return this.originalError.errorDoc;
        }
        else {
            return null;
        }
    }
    get callContext() {
        if (this.originalError.callContext !== undefined) {
            return this.originalError.callContext;
        }
        else {
            return null;
        }
    }
    get cause() {
        return originalError(this.originalError);
    }
    toDetailObject(includeVerbose = false) {
        let output = {
            callsite: this.callsiteString(),
            callContext: this.callContext,
            asString: this.toString(),
            unmappedStack: this.unmappedStack,
            doc: this.errorDoc,
            causeAsString: undefined,
            causeStack: undefined,
        };
        if (includeVerbose) {
            output.causeAsString = this.cause.toString();
            output.causeStack = this.cause.stack;
        }
        return output;
    }
    toStringNodeFormat() {
        return this.callsiteString() + '\n\n' + this.toString() + '\n' + this.unmappedStack.join('\n');
    }
    toVerboseString() {
        const baseString = this.toStringNodeFormat();
        // TODO report top->cause chain
        return (baseString +
            '\n\nVerbose detail:\ncause.toString():\n' +
            this.cause.toString() +
            '\ncause.stack:\n' +
            this.cause.stack);
    }
    callsiteString() {
        return SourceUnmapper_1.callsiteToString(this.callsite);
    }
    toJSON() {
        let { message, stackWhenThrown: stack } = this;
        return {
            message,
            stack,
        };
    }
}
exports.TestScriptError = TestScriptError;
exports.TestScriptDefaultOptions = {
    stricterTypeChecking: false,
    traceResolution: false,
};
async function compileString(source, filename, testScriptOptions) {
    return new Compiler_1.TypeScriptTestScript(source, filename, testScriptOptions).compile();
}
exports.compileString = compileString;
async function compileFile(filename, testScriptOptions) {
    const fileContent = ts.sys.readFile(filename);
    if (fileContent === undefined) {
        return undefined;
    }
    return new Compiler_1.TypeScriptTestScript(fileContent, filename, testScriptOptions).compile();
}
exports.compileFile = compileFile;
async function mustCompileString(source, filename, testScriptOptions) {
    const testScript = await compileString(source, filename, testScriptOptions);
    if (testScript.hasErrors) {
        throw new Error(`unable to compile script ${filename}:\n${testScript.formattedErrorString}`);
    }
    return testScript;
}
exports.mustCompileString = mustCompileString;
async function mustCompileFile(filename, testScriptOptions) {
    const testScript = await compileFile(filename, testScriptOptions);
    if (testScript === undefined) {
        throw new Error(`unable to compile script ${filename}:\nunable to read script at path ${filename}`);
    }
    if (testScript.hasErrors) {
        throw new Error(`unable to compile script ${filename}:\n${testScript.formattedErrorString}`);
    }
    return testScript;
}
exports.mustCompileFile = mustCompileFile;
