"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Test_1 = require("./runtime/Test");
const CancellationToken_1 = require("./utils/CancellationToken");
const TestScript_1 = require("./TestScript");
function delay(t, v) {
    return new Promise(function (resolve) {
        setTimeout(resolve.bind(null, v), t);
    });
}
class Looper {
    constructor(settings, running = true) {
        this.iterations = 0;
        this.cancelled = false;
        if (settings.duration > 0) {
            this.timeout = setTimeout(() => {
                this.cancelled = true;
            }, settings.duration * 1e3);
        }
        this.loopCount = settings.loopCount;
        this.cancelled = !running;
        this.done = new Promise(resolve => (this.doneResolve = resolve));
    }
    stop() {
        this.cancelled = true;
    }
    async kill() {
        if (this._killer !== undefined) {
            this._killer();
        }
        this.cancelled = true;
        await this.done;
    }
    set killer(killCb) {
        this._killer = killCb;
    }
    finish() {
        clearTimeout(this.timeout);
    }
    get continueLoop() {
        const hasInfiniteLoops = this.loopCount <= 0;
        const hasLoopsLeft = this.iterations < this.loopCount;
        return !this.cancelled && (hasLoopsLeft || hasInfiniteLoops);
    }
    async run(iterator) {
        while (this.continueLoop) {
            await iterator(++this.iterations);
        }
        this.finish();
        // XXX perhaps call this in a finally to ensure it gets called
        this.doneResolve();
        return this.iterations;
    }
}
class Runner {
    constructor(clientFactory, testCommander, reporter, logger, testSettingOverrides, launchOptionOverrides, testObserverFactory = x => x) {
        this.clientFactory = clientFactory;
        this.testCommander = testCommander;
        this.reporter = reporter;
        this.logger = logger;
        this.testSettingOverrides = testSettingOverrides;
        this.launchOptionOverrides = launchOptionOverrides;
        this.testObserverFactory = testObserverFactory;
        this.running = true;
    }
    async stop() {
        this.running = false;
        if (this.looper)
            await this.looper.kill();
        if (this.clientPromise)
            (await this.clientPromise).close();
        return;
    }
    async run(testScriptFactory) {
        const testScript = await testScriptFactory();
        this.clientPromise = this.launchClient(testScript);
        await this.runTestScript(testScript, this.clientPromise);
    }
    async launchClient(testScript) {
        const { settings } = testScript;
        const options = this.launchOptionOverrides;
        options.ignoreHTTPSErrors = settings.ignoreHTTPSErrors;
        if (options.chromeVersion === undefined) {
            options.chromeVersion = settings.chromeVersion;
        }
        return this.clientFactory(options);
    }
    async runTestScript(testScript, clientPromise) {
        if (!this.running)
            return;
        let testToCancel;
        try {
            const test = new Test_1.default(await clientPromise, testScript, this.reporter, this.testSettingOverrides, this.testObserverFactory);
            testToCancel = test;
            const { settings } = test;
            if (settings.name) {
                this.logger.info(`
*************************************************************
* Loaded test plan: ${settings.name}
* ${settings.description}
*************************************************************
				`);
            }
            if (settings.duration > 0) {
                this.logger.debug(`Test timeout set to ${settings.duration}s`);
            }
            this.logger.debug(`Test loop count set to ${settings.loopCount} iterations`);
            this.logger.debug(`Settings: ${JSON.stringify(settings, null, 2)}`);
            await test.beforeRun();
            const cancelToken = new CancellationToken_1.CancellationToken();
            this.looper = new Looper(settings, this.running);
            this.looper.killer = () => cancelToken.cancel();
            await this.looper.run(async (iteration) => {
                this.logger.info(`Starting iteration ${iteration}`);
                let startTime = new Date();
                try {
                    await test.runWithCancellation(iteration, cancelToken);
                }
                catch (err) {
                    this.logger.error(`[Iteration: ${iteration}] Error in Runner Loop: ${err.name}: ${err.message}\n${err.stack}`);
                    throw err;
                }
                let duration = new Date().valueOf() - startTime.valueOf();
                this.logger.info(`Iteration completed in ${duration}ms (walltime)`);
            });
            this.logger.info(`Test completed after ${this.looper.iterations} iterations`);
            return;
        }
        catch (err) {
            if (err instanceof TestScript_1.TestScriptError) {
                this.logger.error('\n' + err.toStringNodeFormat());
            }
            else {
                this.logger.error(`flood element error: ${err.message}`);
                this.logger.debug(err.stack);
            }
            // if (process.env.NODE_ENV !== 'production') {
            this.logger.debug(err.stack);
            // }
        }
        if (testToCancel !== undefined) {
            await testToCancel.cancel();
        }
    }
}
exports.Runner = Runner;
class PersistentRunner extends Runner {
    constructor(clientFactory, testCommander, reporter, logger, testSettingOverrides, launchOptionOverrides, testObserverFactory = x => x) {
        super(clientFactory, testCommander, reporter, logger, testSettingOverrides, launchOptionOverrides, testObserverFactory);
        this.stopped = false;
        if (this.testCommander !== undefined) {
            this.testCommander.on('rerun-test', () => this.rerunTest());
        }
    }
    rerunTest() {
        this.logger.info('rerun requested');
        setImmediate(() => this.runNextTest());
    }
    async runNextTest() {
        // destructure for type checking (narrowing past undefined)
        const { clientPromise, testScriptFactory } = this;
        if (clientPromise === undefined) {
            return;
        }
        if (testScriptFactory === undefined) {
            return;
        }
        if (this.looper) {
            await this.looper.kill();
            // await (await clientPromise).reopenPage()
        }
        try {
            await this.runTestScript(await testScriptFactory(), clientPromise);
        }
        catch (err) {
            this.logger.error('an error occurred in the script');
            this.logger.error(err);
        }
    }
    async stop() {
        this.stopped = true;
        this.running = false;
        if (this.looper)
            this.looper.stop();
    }
    async waitUntilStopped() {
        if (this.stopped) {
            return;
        }
        else {
            await delay(1000);
            return this.waitUntilStopped();
        }
    }
    async run(testScriptFactory) {
        this.testScriptFactory = testScriptFactory;
        // TODO detect changes in testScript settings affecting the client
        this.clientPromise = this.launchClient(await testScriptFactory());
        this.rerunTest();
        await this.waitUntilStopped();
        // return new Promise<void>((resolve, reject) => {})
    }
}
exports.PersistentRunner = PersistentRunner;
