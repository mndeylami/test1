"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class StructuredError extends Error {
    constructor(message, data, originalError, source, callContext) {
        super(message);
        this.message = message;
        this._structured = 'yes';
        this.wrappedUnstructured = false;
        this.source = 'unknown';
        Object.setPrototypeOf(this, StructuredError.prototype);
        this.data = data;
        this.originalError = originalError;
        if (source !== undefined) {
            this.source = source;
        }
        this.callContext = callContext;
        Error.captureStackTrace(this, this.constructor);
    }
    copyStackFromOriginalError() {
        if (this.originalError) {
            this.stack = this.originalError.stack;
        }
        return this;
    }
    static liftWithSource(err, source, callContext) {
        if (err._structured === 'yes') {
            ;
            err.callContext = callContext;
            err.source = source;
            return err;
        }
        else {
            return new StructuredError(err.message, { _kind: 'empty' }, err, source, callContext);
        }
    }
    static isA(err) {
        return err._structured === 'yes';
    }
    static cast(err) {
        if (err._structured === 'yes') {
            return err;
        }
        else {
            return undefined;
        }
    }
    static wrapBareError(err, data, source, kind) {
        const serr = new StructuredError(err.message, data, err);
        if (source)
            serr.source = source;
        serr.kind = kind || 'unknown';
        serr.wrappedUnstructured = true;
        return serr;
    }
}
exports.StructuredError = StructuredError;
