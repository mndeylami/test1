"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const knuth_shuffle_1 = require("knuth-shuffle");
class Feeder {
    constructor(instanceID = '', lines = [], pointer = -1, filters = []) {
        this.instanceID = instanceID;
        this.lines = lines;
        this.pointer = pointer;
        this.filters = filters;
        this.resetOnEnd = true;
        this.shuffleAfterLoad = false;
        this.reset();
    }
    append(lines) {
        let { instanceID } = this;
        if (!lines || lines.length === 0)
            return this;
        let newLines = lines.filter((line, index) => this.filters.every(func => func(line, index, instanceID)));
        if (this.shuffleAfterLoad) {
            this.lines = knuth_shuffle_1.knuthShuffle([...this.lines, ...newLines]);
        }
        else {
            this.lines = [...this.lines, ...newLines];
        }
        return this;
    }
    /**
     * Configures the feeder to reset at the end, creating a repeating loop
     */
    circular(loop = true) {
        this.resetOnEnd = loop;
        return this;
    }
    shuffle(shuffle = true) {
        this.shuffleAfterLoad = shuffle;
        return this;
    }
    filter(func) {
        this.filters.push(func);
        return this;
    }
    /**
     * Advances the feed by one iteration
     */
    feed() {
        if (this.isComplete && this.resetOnEnd) {
            this.reset();
        }
        this.pointer++;
        return this.peek();
    }
    /**
     * Reads the data at the current cursor without advancing
     */
    peek() {
        return this.lines[this.pointer] || null;
    }
    reset() {
        this.pointer = -1;
    }
    get size() {
        return this.lines.length;
    }
    get isComplete() {
        return this.pointer >= this.lines.length - 1;
    }
    get isStart() {
        return this.pointer === -1;
    }
    get isEmpty() {
        return this.lines.length === 0;
    }
    toString() {
        let s = [];
        if (this.shuffleAfterLoad) {
            s.push('shuffled');
        }
        if (!this.resetOnEnd) {
            s.push('non-circular');
        }
        return s.join(', ');
    }
}
exports.Feeder = Feeder;
