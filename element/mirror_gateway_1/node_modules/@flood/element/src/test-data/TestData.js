"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Feeder_1 = require("./Feeder");
/**
 * TestDataSource is the instance returned by <[TestDataFactory]>'s methods.
 *
 * Call TestDataSource's methods to configure your data source:
 *
 * ```typescript
 * import { step, Browser, TestData, TestSettings } from '@flood/element'
 * export const settings: TestSettings = {
 *   loopCount: -1
 * }
 *
 * interface Row {
 *   username: string
 *   userID: number
 * }
 * TestData.fromCSV<Row>('users.csv')
 *   .circular(false) // Switch off circular data iteration.
 *                    // By default, when the end of the data is reached, it wraps to the beginning.
 *   .shuffle()       // Shuffle the data
 *
 * export default () => {
 *    step('Step 1', async (browser: Browser, row: Row) => {
 *      // for each loop, a different line from user.csv will be available as `row`
 *    })
 * }
 * ```
 */
class TestDataSource {
    constructor(loader) {
        this.feeder = new Feeder_1.Feeder();
        this.loader = loader;
    }
    /**
     * @internal
     */
    setInstanceID(id) {
        this.feeder.instanceID = id;
    }
    /**
     * @internal
     */
    async load() {
        await this.loader.load();
        this.feeder.append(this.loader.lines);
    }
    /**
     * Instructs the data feeder to repeat the data set when it reaches the end. TestData is circular by default; use this to turn circular data off.
     *
     * @param circular Default: true. Pass `false` to disable.
     */
    circular(circular = true) {
        this.feeder.circular(circular);
        return this;
    }
    /**
     * Shuffles the data set using the Fisher-Yates method. Use this to randomise the order of your data. This will always be applied after filtering.
     * @param shuffle Default: true. Pass `false` to disable.
     */
    shuffle(shuffle = true) {
        this.feeder.shuffle(shuffle);
        return this;
    }
    /**
     * Adds a filter to apply against each line in the data set.
     *
     * Filters can be chained, and will be run in order only if the previous ffilter passed.
     *
     * Example:
     * ```typescript
     * type Row = { browser: string, email: string }
     * TestData.fromCSV("users.csv").filter((line, index, browserID) => line.browser === browserID)
     * ```
     *
     * @param func filter function to compare each line
     */
    filter(func) {
        this.feeder.filter(func);
        return this;
    }
    /**
     * @internal
     */
    feed() {
        if (!this.loader.isLoaded)
            throw new Error(`Test data has not been loaded yet!`);
        return this.feeder.feed();
    }
    /**
     * @internal
     */
    peek() {
        if (!this.loader.isLoaded)
            throw new Error(`Test data has not been loaded yet!`);
        return this.feeder.peek();
    }
    /**
     * @internal
     */
    get size() {
        return this.feeder.size;
    }
    /**
     * @internal
     */
    get isComplete() {
        return this.feeder.isComplete;
    }
    /**
     * @internal
     */
    get isEmpty() {
        return this.feeder.isEmpty;
    }
    /**
     * @internal
     */
    get isStart() {
        return this.feeder.isStart;
    }
    /**
     * @internal
     */
    toString() {
        if (this.loader.isSet) {
            return [this.feeder.toString(), this.loader.toString()].filter(x => x.length).join(', ');
        }
        else {
            return 'no test data';
        }
    }
}
exports.TestDataSource = TestDataSource;
