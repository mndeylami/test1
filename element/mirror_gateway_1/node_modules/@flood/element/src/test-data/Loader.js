"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const util_1 = require("util");
const parseCSV = require("csv-parse/lib/sync");
const readFilePromise = util_1.promisify(fs_1.readFile);
class Loader {
    constructor(filePath, requestedFilename) {
        this.filePath = filePath;
        this.requestedFilename = requestedFilename;
        this.isSet = true;
        this.isLoaded = false;
    }
}
exports.Loader = Loader;
class NullLoader extends Loader {
    constructor() {
        super('', '');
        this.lines = [];
        this.isLoaded = true;
        this.isSet = false;
    }
    async load() {
        this.isLoaded = true;
    }
}
exports.NullLoader = NullLoader;
class DataLoader extends Loader {
    constructor(lines) {
        super('', '');
        this.lines = lines;
        // handle init via TestData.fromData([{}]) to represent a
        // working-but-useless placeholder loader
        // TODO improve this degenerate case
        if (lines.length === 1 && Object.keys(lines[0]).length === 0) {
            this.isSet = false;
        }
    }
    async load() {
        this.isLoaded = true;
    }
    toString() {
        let s = 'inline data\n';
        const pp = util_1.inspect;
        switch (this.lines.length) {
            case 0:
                s += '<empty>';
                break;
            default:
                const show = Math.min(4, this.lines.length);
                s += `[\n`;
                for (let i = 0; i < show; i++) {
                    s += `  ${pp(this.lines[i])},\n`;
                }
                if (this.lines.length > show) {
                    const extra = this.lines.length - show;
                    s += `  ... (${extra} more row${extra !== 1 ? 's' : ''})\n`;
                }
                s += ']';
        }
        return s;
    }
}
exports.DataLoader = DataLoader;
class JSONLoader extends Loader {
    async load() {
        let data = readFilePromise(this.filePath, 'utf8');
        data.catch(err => {
            console.error(err);
        });
        let jsonData = JSON.parse(await data);
        if (Array.isArray(jsonData)) {
            this.lines = jsonData;
        }
        else {
            this.lines = [jsonData];
        }
        if (this.lines.length === 0) {
            throw new Error(`JSON file '${this.requestedFilename}' loaded but contains no rows of data.`);
        }
        this.isLoaded = true;
    }
    toString() {
        return `json data ${this.requestedFilename}`;
    }
}
exports.JSONLoader = JSONLoader;
class CSVLoader extends Loader {
    constructor(filePath, separator = ',', requestedFilename) {
        super(filePath, requestedFilename);
        this.filePath = filePath;
        this.separator = separator;
    }
    async load() {
        let data;
        try {
            data = await readFilePromise(this.filePath, 'utf8');
        }
        catch (e) {
            throw new Error(`unable to read CSV file ${this.filePath}:\ncause: ${e}`);
        }
        this.lines = parseCSV(data, { delimiter: this.separator, columns: true });
        if (this.lines.length === 0) {
            throw new Error(`CSV file '${this.requestedFilename}' loaded but contains no rows of data.\nNote that the first row of a CSV file is used as the header to name columns.\nFor details see https://github.com/flood-io/element/blob/master/packages/element/docs/examples/examples_test_data.md#csv-column-names`);
        }
        this.isLoaded = true;
    }
    toString() {
        return `CSV data ${this.requestedFilename}`;
    }
}
exports.CSVLoader = CSVLoader;
